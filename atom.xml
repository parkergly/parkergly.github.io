<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ashen One</title>
  
  <subtitle>Days of our life</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-08T09:09:31.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Ashen One</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人计划</title>
    <link href="http://example.com/2021/04/08/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    <id>http://example.com/2021/04/08/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/</id>
    <published>2021-04-08T08:57:36.000Z</published>
    <updated>2021-04-08T09:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:600px; height:1000px;" src="https://www.processon.com/embed/606eaa3ee0b34d78c00db6b4"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe id=&quot;embed_dom&quot; name=&quot;embed_dom&quot; frameborder=&quot;0&quot; style=&quot;display:block;width:600px; height:1000px;&quot; src=&quot;https://www.processon.com/emb</summary>
      
    
    
    
    
    <category term="计划" scheme="http://example.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记20210407</title>
    <link href="http://example.com/2021/04/07/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210407/"/>
    <id>http://example.com/2021/04/07/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210407/</id>
    <published>2021-04-07T14:00:00.000Z</published>
    <updated>2021-04-08T08:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="102-二叉树的层序遍历">102. 二叉树的层序遍历</span></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>思路：二叉树的层序遍历通常使用广度优先搜索，广度优先搜索的关键在于利用队列FIFO的特点记录待遍历的节点，利用currentLevelSize变量记录当前层的节点数量，利用currentLevel变量存放当前层的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentLevelSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                currentLevel.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="107-二叉树的层序遍历-ii">107. 二叉树的层序遍历 II</span></h4><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>思路：本题要求自底向上层序遍历，利用ArrayList的方法，将遍历到的每层节点插入List的头部即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentLevelSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                currentLevel.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="103-二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</span></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>思路：利用isOrderLeft标志位记录当前遍历方向，利用Deque双向队列的offerLast和offerFirst方法分别在尾部和头部进行插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">//设置方向标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> isOrderLeft = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Deque&lt;Integer&gt; currentLevel = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentLevelSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(isOrderLeft) currentLevel.offerLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> currentLevel.offerFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(currentLevel));</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="994-腐烂的橘子">994. 腐烂的橘子</span></h4><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><ul><li><p>值 0 代表空单元格；</p></li><li><p>值 1 代表新鲜橘子；</p></li><li><p>值 2 代表腐烂的橘子。</p></li></ul><p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p>思路：一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。</span></span><br><span class="line"><span class="comment">        然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。</span></span><br><span class="line"><span class="comment">        由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; positions = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span> freshOrangeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) freshOrangeCount++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) positions.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(freshOrangeCount == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minutes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!positions.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> currentsize = positions.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentsize; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] position = positions.poll();</span><br><span class="line">                <span class="keyword">int</span> x = position[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = position[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                    freshOrangeCount--;</span><br><span class="line">                    <span class="keyword">if</span>(freshOrangeCount == <span class="number">0</span>)<span class="keyword">return</span> minutes;</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//上下左右</span></span><br><span class="line">                <span class="keyword">if</span>(y-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; grid[x][y-<span class="number">1</span>] == <span class="number">1</span>) positions.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y-<span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(x-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; grid[x-<span class="number">1</span>][y] == <span class="number">1</span>) positions.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x-<span class="number">1</span>,y&#125;);</span><br><span class="line">                <span class="keyword">if</span>(y+<span class="number">1</span> &lt; col &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">1</span>) positions.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y+<span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(x+<span class="number">1</span> &lt; row &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">1</span>) positions.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x+<span class="number">1</span>,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            minutes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(freshOrangeCount!=<span class="number">0</span>)<span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> minutes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="127-单词接龙">127. 单词接龙</span></h4><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 beginWord 。</li><li>序列中最后一个单词是 endWord 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 wordList 中的单词。</li></ul><p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><p>思路：已知目标顶点的情况下，可以分别从起点和目标顶点（终点）执行广度优先遍历，直到遍历的部分有交集。这种方式搜索的单词数量会更小一些；更合理的做法是，每次从单词数量小的集合开始扩散；这里 beginVisited 和 endVisited 交替使用，等价于单向 BFS 里使用队列，每次扩散都要加到总的 visited 里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先将wordList放入哈希表中，以便于判断某个单词是否在wordlist中</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span>(wordList.size() == <span class="number">0</span> || !wordSet.contains(endWord))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将访问过的word添加到visited哈希表中</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//分别用左边和右边扩散的哈希表代替单向BFS里的队列，它们在双向BFS的过程中交替使用</span></span><br><span class="line">        Set&lt;String&gt; beginVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        beginVisited.add(beginWord);</span><br><span class="line">        Set&lt;String&gt; endVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        endVisited.add(endWord);</span><br><span class="line">        <span class="comment">//执行双向BFS，左右交替扩散的步数之和为所求</span></span><br><span class="line">        <span class="keyword">int</span> step =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!beginVisited.isEmpty() &amp;&amp; !endVisited.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//优先选择更小的哈希表进行扩散</span></span><br><span class="line">            <span class="keyword">if</span>(beginVisited.size() &gt; endVisited.size())&#123;</span><br><span class="line">                Set&lt;String&gt; temp = beginVisited;</span><br><span class="line">                beginVisited = endVisited;</span><br><span class="line">                endVisited = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; nextLevelVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String word: beginVisited) &#123;</span><br><span class="line">                <span class="keyword">for</span>(String word2: wordList)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isChangeable(word,word2))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(endVisited.contains(word2))<span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(word2))&#123;</span><br><span class="line">                            visited.add(word2);</span><br><span class="line">                            nextLevelVisited.add(word2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            beginVisited = nextLevelVisited;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isChangeable</span><span class="params">(String word1,String word2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;=<span class="number">2</span> || count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;102-二叉树的层序遍历&quot;&gt;102. 二叉树的层序遍历&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;给你一个二叉树，请你返回其按 &lt;strong&gt;层序遍历&lt;/strong&gt; 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;思路：二叉树的层序遍历通常</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="广度优先搜索" scheme="http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记20210406</title>
    <link href="http://example.com/2021/04/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210406/"/>
    <id>http://example.com/2021/04/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210406/</id>
    <published>2021-04-06T14:00:00.000Z</published>
    <updated>2021-04-07T05:16:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="129-求根节点到叶节点数字之和">129. 求根节点到叶节点数字之和</span></h4><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p>链接：<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers</a></p><p>思路：对于每个叶子节点而言，应该都要返回一个当前路径对应的数字，对于非叶子节点而言，应该将其左子树和右子树返回的路径和相加（在return中实现）。每次递归需要传递当前路径的数字排列，所以需要number变量传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DFS(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode node, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//构造当前节点的路径和</span></span><br><span class="line">        number = number * <span class="number">10</span> + node.val;</span><br><span class="line">        <span class="comment">//若为叶子节点则加上当前路径和</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="comment">//递归执行</span></span><br><span class="line">        <span class="keyword">return</span> DFS(node.left,number) + DFS(node.right, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="199-二叉树的右视图">199. 二叉树的右视图</span></h4><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view">https://leetcode-cn.com/problems/binary-tree-right-side-view</a></p><p>思路：利用深度优先搜索，优先遍历右子树，利用rightViewNum的大小来记录当前右视图的最大深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; rightViewNum = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        DFS(root,rightViewNum,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> rightViewNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode node, List&lt;Integer&gt; rightViewNum, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(height &gt; rightViewNum.size()) rightViewNum.add(node.val);</span><br><span class="line">        DFS(node.right, rightViewNum, height+<span class="number">1</span>);</span><br><span class="line">        DFS(node.left, rightViewNum, height+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="695-岛屿的最大面积">695. 岛屿的最大面积</span></h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island">https://leetcode-cn.com/problems/max-area-of-island</a><br>思路：利用visited数组记录已经访问过的节点（也可以通过将访问过的节点置零（沉岛法）），对于每一个未访问过的节点进行深度优先搜索（分别对四个方向进行深度优先搜索，并标记访问过的节点）。利用area统计当前岛屿的总大小，每个岛屿遍历结束后与maxArea进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] != <span class="keyword">true</span> &amp;&amp; grid[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> area = DFS(visited,grid,i,j);</span><br><span class="line">                    maxArea = Math.max(area, maxArea);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断递归退出条件，1.数组越界，2.该位置为0，3.该点已访问过。</span></span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= rows || row &lt;<span class="number">0</span>  || col &gt;= cols || col &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[row][col] == <span class="number">0</span> || visited[row][col] == <span class="keyword">true</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到新的节点，1.将visited置为true，2.递归寻找下一个节点（向下，向右）。</span></span><br><span class="line">        visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">        area += DFS(visited,grid,row,col+<span class="number">1</span>);</span><br><span class="line">        area += DFS(visited,grid,row,col-<span class="number">1</span>);</span><br><span class="line">        area += DFS(visited,grid,row+<span class="number">1</span>,col);</span><br><span class="line">        area += DFS(visited,grid,row-<span class="number">1</span>,col);</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="200-岛屿数量">200. 岛屿数量</span></h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a><br>思路：利用visited数组记录已经访问过的节点（也可以通过将访问过的节点置零（沉岛法）），对于每一个未访问过的节点进行深度优先搜索（分别对四个方向进行深度优先搜索，并标记访问过的节点）。利用count统计访问过的每个岛屿的第一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] != <span class="keyword">true</span> &amp;&amp; grid[i][j] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    DFS(visited,grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">boolean</span>[][] visited, <span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断递归退出条件，1.数组越界，2.该位置为0，3.该点已访问过。</span></span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= rows || row &lt;<span class="number">0</span>  || col &gt;= cols || col &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[row][col] == <span class="string">&#x27;0&#x27;</span> || visited[row][col] == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//找到新的节点，1.将visited置为true，2.递归寻找下一个节点（向下，向右）。</span></span><br><span class="line">        visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        DFS(visited,grid,row,col+<span class="number">1</span>);</span><br><span class="line">        DFS(visited,grid,row,col-<span class="number">1</span>);</span><br><span class="line">        DFS(visited,grid,row+<span class="number">1</span>,col);</span><br><span class="line">        DFS(visited,grid,row-<span class="number">1</span>,col);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="100-相同的树">100. 相同的树</span></h4><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>思路：利用DFS遍历每个节点，对比节点是否一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断退出条件</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span> || p.val != q.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="124-二叉树中的最大路径和">124. 二叉树中的最大路径和</span></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum</a><br>思路：因为要记录所有路径中的最大路径和，所以需要一个全局变量maxSum进行统计，初始值设置为Integer.MIN_VALUE。对根节点进行DFS，对于每一个节点父节点而言，其子节点的最大路径和必定是从一个子树路径而来的，所以return的时候是子节点+max（子节点的左子树路径和，右子树路径和），当路径和为负数时，返回值为0，即代表放弃其子节点的相关路径。对于maxSum而言，其最大值就是当前节点的值加上其左右子树的路径和（最小值为0）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxSum = Integer.MIN_VALUE;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightSum = dfs(root.right);</span><br><span class="line">    maxSum = Math.max(maxSum, leftSum + rightSum + root.val);</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>,Math.max(leftSum,rightSum)+ root.val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;129-求根节点到叶节点数字之和&quot;&gt;129. 求根节点到叶节点数字之和&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。&lt;br&gt;每条从根节点到叶节点的路径都代表一个数字：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记20210404</title>
    <link href="http://example.com/2021/04/04/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210404/"/>
    <id>http://example.com/2021/04/04/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210404/</id>
    <published>2021-04-04T14:39:55.000Z</published>
    <updated>2021-04-05T01:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</span></h1><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过 1 的二叉树。</p><p>思路：通过递归不断组建左右子树，每次递归都将<code>（left + right）/ 2</code> 作为根节点（中点），通过递归获得其左右子树，最终完成高度平衡的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//构建当前子树</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = buildBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="98-验证二叉搜索树">98. 验证二叉搜索树</span></h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>思路：由于二叉搜索树的中序遍历是严格递增的，只需要列出给定的二叉树的中序遍历，并判断其是否递增即可。利用<code>preNodeValue</code>记录上个节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> preNodeValue = Long.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//访问左子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//访问当前节点，与中序遍历的前一个节点比较，</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= preNodeValue) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//更新preNodeValue的值</span></span><br><span class="line">        preNodeValue = root.val;</span><br><span class="line">        <span class="comment">//访问右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="110-平衡二叉树">110. 平衡二叉树</span></h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p>思路：通过递归计算左右子树的高度，从下往上进行计算，并判断左右子树是否符合<strong>高度平衡</strong>的要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束条件,当前节点为空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先递归判断左右子树是否平衡</span></span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//再返回当前节点高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight,rightHeight) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="112-路径总和">112. 路径总和</span></h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p><p>叶子节点 是指没有子节点的节点。</p><p>思路：利用深度优先搜索的思想，通过递归找到叶子结点，并计算路径和是否符合要求，在每次递归过程中要维护剩余路径和。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判读是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>  targetSum == root.val;&#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="114-二叉树展开为链表">114. 二叉树展开为链表</span></h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li><p>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</p></li><li><p>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</p></li></ul><p>思路：先通过先序遍历得到先序遍历的节点List，然后用循环修改其左右子树的指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        preOrder(root,list);</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            TreeNode current = list.get(i),next= list.get(i+<span class="number">1</span>);</span><br><span class="line">            current.left = <span class="keyword">null</span>;</span><br><span class="line">            current.right = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preOrder(root.left, list);</span><br><span class="line">            preOrder(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="144-二叉树的前序遍历">144. 二叉树的前序遍历</span></h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p>思路：利用递归完成前序遍历，根→左→右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; preOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrderTraversal(root, preOrder);</span><br><span class="line">        <span class="keyword">return</span> preOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; preOrder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preOrder.add(root.val);</span><br><span class="line">            preOrderTraversal(root.left,preOrder);</span><br><span class="line">            preOrderTraversal(root.right,preOrder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代解法</span></span><br></pre></td></tr></table></figure><h1><span id="94-二叉树的中序遍历">94. 二叉树的中序遍历</span></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p>思路：利用递归完成前序遍历，左→根→右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; inorder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorderTraversal(root, inorder);</span><br><span class="line">        <span class="keyword">return</span> inorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inorderTraversal(root.left, inorder);</span><br><span class="line">            inorder.add(root.val);</span><br><span class="line">            inorderTraversal(root.right, inorder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代解法</span></span><br></pre></td></tr></table></figure><h1><span id="145-二叉树的后序遍历">145. 二叉树的后序遍历</span></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>后序</strong> 遍历。</p><p>思路：利用递归完成前序遍历，左→右→根</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; postorder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorderTraversal(root, postorder);</span><br><span class="line">        <span class="keyword">return</span> postorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            postorderTraversal(root.left, postorder);</span><br><span class="line">            postorderTraversal(root.right, postorder);</span><br><span class="line">            postorder.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代解法</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;108-将有序数组转换为二叉搜索树&quot;&gt;108. 将有序数组转换为二叉搜索树&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。&lt;/p&gt;
&lt;p&gt;高度平</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="http://example.com/2021/04/02/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/04/02/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-04-02T11:42:10.000Z</published>
    <updated>2021-04-02T11:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="数组">数组</span></h2><p><strong>LC. 59 螺旋矩阵Ⅱ</strong></p><p>简介：给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>技巧：directions二维数组来代表方向的变化，通过directionIndex来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxNum=n*n;</span><br><span class="line">    <span class="keyword">int</span> curNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(curNum &lt;= maxNum)&#123;</span><br><span class="line">        matrix[row][column] = curNum;</span><br><span class="line">        curNum++;</span><br><span class="line">        <span class="comment">//调整方向</span></span><br><span class="line">        <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nextRow &gt;= n || nextRow &lt; <span class="number">0</span> || nextColumn &gt;= n || nextColumn &lt; <span class="number">0</span> || matrix[nextRow][nextColumn] != <span class="number">0</span>)&#123;</span><br><span class="line">            directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        row = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">        column = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LC.54 螺旋矩阵</strong></p><p>简介：给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p>技巧：使用辅助矩阵visited来判断某个位置是否被访问过，visited数组的类型应为布尔值，要对程序的输入做异常判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取二维数组的行和列</span></span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] visited = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxNum = rows * columns;</span><br><span class="line">    <span class="keyword">int</span> curNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> curRow = <span class="number">0</span>, curColumn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(curNum &lt;= maxNum)&#123;</span><br><span class="line">        curNum++;</span><br><span class="line">        order.add(matrix[curRow][curColumn]);</span><br><span class="line">        visited[curRow][curColumn] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextRow = curRow + directions[directionIndex][<span class="number">0</span>], nextColumn = curColumn + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nextRow &gt;= rows || nextRow &lt; <span class="number">0</span> || nextColumn &gt;= columns || nextColumn &lt; <span class="number">0</span> || visited[nextRow][nextColumn] == <span class="number">1</span>)</span><br><span class="line">            directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        curRow = curRow + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">        curColumn = curColumn + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LC.11 乘最多水的容器</strong></p><p>简介：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a></p><p>技巧：利用双指针，left&amp;right，滑动判断最大面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>, rightIndex = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftIndex &lt; rightIndex)&#123;</span><br><span class="line">        <span class="keyword">int</span> curRes = (rightIndex - leftIndex) * Math.min(height[leftIndex],height[rightIndex]);</span><br><span class="line">        maxRes = Math.max(maxRes, curRes);</span><br><span class="line">        <span class="keyword">if</span>(height[leftIndex] &lt;= height[rightIndex])&#123;</span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rightIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>JZ.04 二维数组中的查找</strong></p><p>简介：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a><br>思路：从右上角开始判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length - <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; matrix.length &amp;&amp; j &lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LC.73 矩阵置零</strong></p><p>简介：给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a><strong>算法</strong>。**</p><p>思路：利用额外空间记录为0的行号和列号，再统一置零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeros</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] flagedRows = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">    <span class="keyword">boolean</span>[] flagedCols = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                flagedRows[i] = <span class="keyword">true</span>;</span><br><span class="line">                flagedCols[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flagedRows[i] || flagedCols[j])&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rotate-image/">LC48. 旋转图像</a></p><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>思路：通过先水平翻转，再沿主对角线翻转的方式实现90度旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = rows;</span><br><span class="line">    <span class="comment">//水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[rows-<span class="number">1</span>-i][j];</span><br><span class="line">            matrix[rows-<span class="number">1</span>-i][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//沿左对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="动态规划">动态规划</span></h2><p><strong>LC.115不同的子序列</strong></p><p>简介：给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）<br>链接：<a href="https://leetcode-cn.com/problems/distinct-subsequences">https://leetcode-cn.com/problems/distinct-subsequences</a><br><img src="C:\Users\parke\AppData\Roaming\Typora\typora-user-images\image-20210317204004771.png" alt="image-20210317204004771" style="zoom: 67%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; t.length())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printMatrix(dp);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(j-<span class="number">1</span>) == t.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">          dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//printMatrix(dp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printMatrix(dp);</span></span><br><span class="line">    <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>LC.53 最大子序和</strong></p><p>简介：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>思路：一维动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        nums[i] = Math.max(nums[i], nums[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LC.62不同路径</strong></p><p>简介：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a></p><p>思路：动态规划    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span> || i==<span class="number">0</span>)dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n ;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/unique-paths-ii/">LC.63不同路径 II</a></strong></p><p>简介：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>思路：动态规划解决，遇到障碍物时要减去减少的可能路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] rows = <span class="keyword">new</span> <span class="keyword">int</span>[m], cols = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j]==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n ;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printMatrix(dp);</span></span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC.120 三角形最小路径和</p><p>简介：给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。<br>链接：<a href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a><br>思路：运用动态规划，用二维数组记录状态，考虑好边界条件和推导式的特殊情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//初始化dp</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//每行的最左测</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每行的最右侧</span></span><br><span class="line">        dp[i][i] = dp[i-<span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minTotal = dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt; n ;i++)&#123;</span><br><span class="line">        minTotal = Math.min(minTotal, dp[n-<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="链表">链表</span></h2><p><strong>LC.92 反转链表Ⅱ</strong></p><p>简介：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">https://leetcode-cn.com/problems/reverse-linked-list-ii</a></p><p>思路：考虑到头节点可能变化的链表题，可以建立dummy node 来作为虚拟头节点。链表的反转可以通过三个点完成，curNode,nextNode,nextNextNode. 先将nextNode指向curNode，再使curNode=nextnode，nextnode=nextNextNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; left - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    pre = pre.next;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode curNode = pre.next, nextNode = curNode.next;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; right - left; i++)&#123;</span><br><span class="line">    ListNode nextNextNode = nextNode.next;</span><br><span class="line">    nextNode.next = curNode;</span><br><span class="line">    curNode = nextNode;</span><br><span class="line">    nextNode = nextNextNode;</span><br><span class="line">  &#125;</span><br><span class="line">  pre.next.next=nextNode;</span><br><span class="line">  pre.next = curNode;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JZ.06从尾到头打印链表</p><p>简介：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>思路：1.用栈的特性解题，2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(;head != <span class="keyword">null</span>;head = head.next)&#123;</span><br><span class="line">        stack.add(head.val);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        res[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC82<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></p><p>简介：存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。返回同样按升序排列的结果链表。</p><p>思路：针对头节点可能删除的情况，采用dummy node，注意考虑链表节点是否为null（null.next会报错）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode preNode = dummy;</span><br><span class="line">    ListNode currentNode = head;</span><br><span class="line">    <span class="keyword">while</span>(currentNode != <span class="keyword">null</span> &amp;&amp; currentNode.next!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentNode.next.val == currentNode.val)&#123;</span><br><span class="line">            ListNode postNode = currentNode.next;</span><br><span class="line">            <span class="keyword">while</span>(postNode!= <span class="keyword">null</span> &amp;&amp; postNode.val == currentNode.val)&#123;</span><br><span class="line">                postNode = postNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode.next = postNode;</span><br><span class="line">            currentNode = postNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            preNode = currentNode;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC328奇偶列表</p><p>简介：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list">https://leetcode-cn.com/problems/odd-even-linked-list</a></p><p>思路：要考虑边界值，通过维护两个指针达到奇偶分离的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode evenHead = head.next;</span><br><span class="line">    ListNode oddNode = head, evenNode = evenHead;</span><br><span class="line">    <span class="keyword">while</span>(evenNode != <span class="keyword">null</span> &amp;&amp; evenNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        oddNode.next = evenNode.next;</span><br><span class="line">        evenNode.next = evenNode.next.next;</span><br><span class="line">        oddNode = oddNode.next;</span><br><span class="line">        evenNode = evenNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    oddNode.next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC19</p><p>简介：</p><p>思路：dummy 节点 ，双指针记录倒数第n个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为头节点可能被删除，所以建立dummy节点</span></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line"><span class="comment">//建立双指针，记录倒数第n个数</span></span><br><span class="line">ListNode first = head;</span><br><span class="line">ListNode second = dummy;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    first = first.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = first.next;</span><br><span class="line">    second = second.next;</span><br><span class="line">&#125;</span><br><span class="line">second.next = second.next.next;</span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure><p>LC83.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p>思路：遍历链表即可，如有重复，将该节点从链表中移除，注意判断结束条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode curNode = head;</span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="keyword">null</span> &amp;&amp; curNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curNode.val == curNode.next.val)&#123;</span><br><span class="line">            curNode.next = curNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="栈">栈</span></h2><p>LC150</p><p>简介：根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation</a><br>思路：运用栈的思想进行运算，遇到数字放入，遇到符号计算，记住String到Int类型的转换，可以编写辅助函数简化程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String token: tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isNumber(token))&#123;</span><br><span class="line">            stack.push(Integer.parseInt(token));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = stack.pop(),num1 = stack.pop();</span><br><span class="line">            <span class="keyword">switch</span> (token)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> :  stack.push(num1+num2);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> :  stack.push(num1-num2);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> :  stack.push(num1*num2);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> :  stack.push(num1/num2);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>) &amp;&amp;s.equals(<span class="string">&quot;-&quot;</span>) &amp;&amp;s.equals(<span class="string">&quot;*&quot;</span>) &amp;&amp;s.equals(<span class="string">&quot;/&quot;</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC456.132模式</p><p>简介：给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</p><p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false<br>链接：<a href="https://leetcode-cn.com/problems/132-pattern">https://leetcode-cn.com/problems/132-pattern</a><br>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; possibleK = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    possibleK.push(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> maxK = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; maxK)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!possibleK.isEmpty() &amp;&amp; nums[i] &gt; possibleK.peek())&#123;</span><br><span class="line">            maxK = possibleK.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; maxK)&#123;</span><br><span class="line">            possibleK.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="位运算">位运算</span></h2><p>LC.191 位1的个数</p><p>简介：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p>思路：n&amp;（1&lt;&lt;i）  或者 n&amp;（n-1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;(<span class="number">1</span>&lt;&lt;i)) != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="排序">排序</span></h2><p>LC.56 <a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></p><p>简介：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>思路：先针对左端点排序（调用sort方法并自定义比较器），再通过对比右端点合并区间，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">//按区间的左端点排序</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>],right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(merged.size() == <span class="number">0</span> || merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>] &lt; left )&#123;</span><br><span class="line">            merged.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(right, merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC148 排序链表</p><p>简介：    给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> ，</p><p>思路：使用归并排序，且不使用递归的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span> ,head);</span><br><span class="line">    <span class="comment">//最外层循环，控制子链表的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> subLength = <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//两两一组，遍历目前长度下的所有子链表</span></span><br><span class="line">        ListNode curNode = dummy.next, preNode = dummy;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//第一个子链表</span></span><br><span class="line">            ListNode head1 = curNode;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curNode.next!= <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                curNode =curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二个子链表</span></span><br><span class="line">            ListNode head2 = curNode.next;</span><br><span class="line">            curNode.next = <span class="keyword">null</span>;</span><br><span class="line">            curNode = head2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curNode != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                curNode = curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录下剩余的链表的起始位置</span></span><br><span class="line">            ListNode next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                next = curNode.next;</span><br><span class="line">                curNode.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//合并子链表</span></span><br><span class="line">            ListNode merged = merge(head1,head2);</span><br><span class="line">            <span class="comment">//将子链表重新插入原链表中</span></span><br><span class="line">            preNode.next = merged;</span><br><span class="line">            <span class="comment">//重新定位preNode和curNode</span></span><br><span class="line">            <span class="keyword">while</span>(preNode.next != <span class="keyword">null</span>)&#123;preNode= preNode.next;&#125;</span><br><span class="line">            curNode=next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode curNode = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            curNode.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curNode.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) curNode.next = l1;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) curNode.next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="贪心算法">贪心算法</span></h2><p><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></p><h2><span id="待做题">待做题</span></h2><p>LC969煎饼排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;数组&quot;&gt;数组&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;LC. 59 螺旋矩阵Ⅱ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简介：给你一个正整数 &lt;code&gt;n&lt;/code&gt; ，生成一个包含 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n2&lt;/code&gt; 所</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>初探反射</title>
    <link href="http://example.com/2021/04/02/%E5%88%9D%E6%8E%A2%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2021/04/02/%E5%88%9D%E6%8E%A2%E5%8F%8D%E5%B0%84/</id>
    <published>2021-04-02T03:18:04.000Z</published>
    <updated>2021-04-02T11:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="什么是反射">什么是反射？</span></h1><p>​    反射是JAVA的特性之一，其运行JAVA程序在运行时获取类的信息，并且可以操作类或对象的内部属性。</p><p>​    JAVA的反射机制使得程序可以在运行时动态的创建对象并调用其属性，不需要在编译期间确定对象的类型。当通过反射与一个未知类型的对象打交道时，JVM只是简单的检查这个对象，看它属于哪一个类，在用它做其他事情之前必须先加载那个类的Class对象。对于RTTI而言，编译器在编译是打开和检查.class文件。而对于反射机制来说，.class文件是在运行时被打开和检查的。</p><p>​    JAVA的反射主要有以下几个功能：</p><ul><li><p>​    在运行时判断任意一个对象所属的类；</p></li><li><p>​    在运行时构造任意一个类的对象；</p></li><li><p>​    在运行时判断任意一个类所具有的成员变量；</p></li><li><p>​    在运行时调用任意一个对象的方法；</p></li></ul><h1><span id="反射的用途">反射的用途</span></h1><p>​        反射最重要的用途就是开发各种通用框架。如Spring就是配置化的，需要根据配置文件加载不同的对象或类，调用不同的方法，这时候就需要用到反射，在运行时动态加载对象。</p><h1><span id="反射的基本运用">反射的基本运用</span></h1><p>​        Class类与java.lang.reflect类库一起对反射的概念进行了支持，reflect类库包含了Field、Method和Constructor类。这些类型的对象会由JVM在运行时创建，用于未知类中的成员。所以可以运用Constructor来创建新的对象，用get()和set()方法读取和修改Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。此外，还可以调用getFields()、getMethods()和getConstructors()等方法获得更多类的信息。以下是反射一些基本运用的示例：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;什么是反射&quot;&gt;什么是反射？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;​    反射是JAVA的特性之一，其运行JAVA程序在运行时获取类的信息，并且可以操作类或对象的内部属性。&lt;/p&gt;
&lt;p&gt;​    JAVA的反射机制使得程序可以在运行时动态的创建对象并调用其属</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
    <category term="反射" scheme="http://example.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 个人博客搭建教程</title>
    <link href="http://example.com/2021/04/01/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2021/04/01/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2021-04-01T05:41:06.000Z</published>
    <updated>2021-04-01T05:41:06.518Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/04/01/hello-world/"/>
    <id>http://example.com/2021/04/01/hello-world/</id>
    <published>2021-03-31T18:04:30.893Z</published>
    <updated>2021-03-31T18:04:30.893Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
