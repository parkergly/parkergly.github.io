{"meta":{"title":"Ashen One","subtitle":"Days of our life","description":"","author":"Ashen One","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-31T18:51:16.462Z","updated":"2021-03-31T18:51:16.456Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-31T18:51:02.420Z","updated":"2021-03-31T18:51:02.416Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【LeetCode每日题解】20210606","slug":"【LeetCode每日题解】20210606","date":"2021-06-06T19:53:05.080Z","updated":"2021-06-06T19:52:32.000Z","comments":true,"path":"posts/a985094a/","link":"","permalink":"http://example.com/posts/a985094a/","excerpt":"","text":"【LeetCode每日题解】20210606【每日一题】474. 一和零链接：https://leetcode-cn.com/problems/ones-and-zeroes/ 题目： 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 思路：要找出最大子集，需要统计strs中每个元素1的数量和0的数量。 代码： 基础解法 12345678910111213141516171819202122class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; int length = strs.length; int[][][] dp = new int[length+1][m+1][n+1]; for (int i = 1; i &lt;= length; i++) &#123; int zeroCount=0,oneCount=0; for (char c: strs[i-1].toCharArray()) &#123; if(c==&#x27;1&#x27;)oneCount++; else zeroCount++; &#125; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k &lt;= n; k++) &#123; dp[i][j][k] = dp[i-1][j][k]; if(j&gt;=zeroCount &amp;&amp; k&gt;=oneCount)&#123; dp[i][j][k] = Math.max(dp[i][j][k],dp[i-1][j-zeroCount][k-oneCount]+1); &#125; &#125; &#125; &#125; return dp[length][m][n]; &#125;&#125; 空间优化，去掉物品维度 12345678910111213141516171819class Solution &#123; public int findMaxForm2(String[] strs, int m, int n) &#123; int length = strs.length; int[][] dp = new int[m+1][n+1]; for (int i = 1; i &lt;= length; i++) &#123; int zeroCount=0,oneCount=0; for (char c: strs[i-1].toCharArray()) &#123; if(c==&#x27;1&#x27;)oneCount++; else zeroCount++; &#125; for (int j = m; j &gt;= zeroCount; j--) &#123; for (int k = n; k &gt;= oneCount; k--) &#123; dp[j][k] = Math.max(dp[j][k],dp[j-zeroCount][k-oneCount]+1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ 总结： 【动态规划 01背包问题】416. 分割等和子集链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/ 题目： 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 思路： 代码： 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0,length = nums.length,maxNum = 0; for (int n: nums) &#123; sum+=n; maxNum = Math.max(maxNum,n); &#125; //不可能分割为两个等和数组的情况 if(length &lt; 2 || sum % 2 != 0 || maxNum &gt; sum/2) return false; int maxCapcity = sum / 2; int target = maxCapcity; int[][] dp = new int[length][maxCapcity+1]; //dp数组初始化 for (int i = 0; i &lt;= target; i++) &#123; dp[0][i] = i &gt;= nums[0] ? nums[0]:0; &#125; for (int i = 1; i &lt; length; i++) &#123; int t = nums[i]; for (int j = 0; j &lt;= maxCapcity; j++) &#123; //不选择第i个数字 int no = dp[i-1][j]; //选择第i个数字 int yes = j &gt;= t ? dp[i-1][j-t]+t : 0; dp[i][j] = Math.max(no,yes); if(dp[i][j]==target)return true; &#125; &#125; return false; &#125;&#125; 时间复杂度：$O(n+m)$ 空间复杂度：$O(n)$","categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]},{"title":"【LeetCode每日题解】20210605","slug":"【LeetCode每日题解】20210605","date":"2021-06-05T16:10:12.612Z","updated":"2021-06-05T16:10:12.612Z","comments":true,"path":"posts/308c58f0/","link":"","permalink":"http://example.com/posts/308c58f0/","excerpt":"","text":"【LeetCode每日题解】20210605【每日一题】203. 移除链表元素链接：https://leetcode-cn.com/problems/remove-linked-list-elements/ 题目：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 思路：移除链表中的节点可以通过递归和迭代的方式求解。利用dummy节点可以解决头节点被删除的情况。 代码： 迭代法实现 1234567891011121314class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode currentNode = dummy; while(currentNode.next!=null)&#123; if(currentNode.next.val == val)&#123; currentNode.next = currentNode.next.next; &#125; else currentNode = currentNode.next; &#125; return dummy.next; &#125;&#125; 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ 总结：除了迭代法外，这题还可以通过递归的方式删除链表中的节点。 【前缀和】1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/ 题目： 给你一个下标从 0 开始的正整数数组 candiesCount，其中 candiesCount[i] 表示你拥有的第i类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 思路： 要判断是否能在满足吃糖数量的限制条件的情况下在特定日期吃到特定种类的糖，需要利用吃糖数量的限制计算出吃到特定种类糖的最早/最晚时间，再判断特定日期是否在区间内即可。 首先，为了方便计算，需要预处理出candiesCount的前缀和数组candieSumCount用于表示第i类糖果前所有糖果的数量和。 其次，要注意题目是从第0天开始吃糖的，我们计算时都是从第一天开始计算的，所以需要将特定时间+1。 计算吃到第t类糖果的 [最早/最晚] 时间： 最早时间（吃到第一颗favoriteType糖的最早时间）：以最大速率dailyCap吃糖，吃掉favoriteType类之前所有糖果的时间向下取整并加1： \\lfloor \\frac{candiesSumCount[favoriteType]}{dailyCap} \\rfloor + 1 最晚时间：(吃完最后一颗favoriteType糖的最晚时间)：以最小速率1吃糖，吃掉所有 favoriteType类糖的时间: candiesSumCount[favoriteType+1] 代码： 1234567891011121314151617181920212223class Solution &#123; public boolean[] canEat(int[] candiesCount, int[][] queries) &#123; boolean[] answer = new boolean[queries.length]; //前缀和数组，使用long防止溢出 long[] candiesSumCount = new long[candiesCount.length+1]; //计算想要吃到指定类型的糖之前需要吃的糖的数量 for (int i = 1; i &lt;= candiesCount.length; i++) &#123; candiesSumCount[i] = candiesSumCount[i-1]+candiesCount[i-1]; &#125; for (int i = 0; i &lt; queries.length; i++) &#123; int favoriteType = queries[i][0]; //因为后续计算是从第1天开始的，所以将题目设定的时间加1 int favoriteDay = queries[i][1]+1; int dailyCap = queries[i][2]; //计算能吃到糖的最早时间=以最大速率吃完前面的糖的时间（向下取整）+1 long min = candiesSumCount[favoriteType] / dailyCap + 1; //能吃到糖的最晚时间=吃光喜欢的糖需要的时间 long max = candiesSumCount[favoriteType+1]; answer[i] = favoriteDay&gt;=min &amp;&amp; favoriteDay&lt;=max; &#125; return answer; &#125;&#125; 时间复杂度：$O(n+m)$，candiesSum的数组长度为n, queries的数组长度为m 空间复杂度：$O(n)$","categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-05T13:13:45.237Z","updated":"2021-06-05T13:13:45.237Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"http://example.com/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]}