{"meta":{"title":"Ashen One","subtitle":"Days of our life","description":"","author":"Ashen One","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-31T18:51:16.462Z","updated":"2021-03-31T18:51:16.456Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-31T18:51:02.420Z","updated":"2021-03-31T18:51:02.416Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【LeetCode每日题解】20210605","slug":"【LeetCode每日题解】20210605","date":"2021-06-05T16:01:20.617Z","updated":"2021-06-05T16:00:50.000Z","comments":true,"path":"posts/308c58f0/","link":"","permalink":"http://example.com/posts/308c58f0/","excerpt":"","text":"【LeetCode每日题解】20210605【每日一题】203. 移除链表元素链接：https://leetcode-cn.com/problems/remove-linked-list-elements/ 题目：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 思路：移除链表中的节点可以通过递归和迭代的方式求解。利用dummy节点可以解决头节点被删除的情况。 代码： 迭代法实现 1234567891011121314class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode currentNode = dummy; while(currentNode.next!=null)&#123; if(currentNode.next.val == val)&#123; currentNode.next = currentNode.next.next; &#125; else currentNode = currentNode.next; &#125; return dummy.next; &#125;&#125; 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ 总结：除了迭代法外，这题还可以通过递归的方式删除链表中的节点。 【前缀和】1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/ 题目： 给你一个下标从 0 开始的正整数数组 candiesCount，其中 candiesCount[i] 表示你拥有的第i类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 思路： 要判断是否能在满足吃糖数量的限制条件的情况下在特定日期吃到特定种类的糖，需要利用吃糖数量的限制计算出吃到特定种类糖的最早/最晚时间，再判断特定日期是否在区间内即可。 首先，为了方便计算，需要预处理出candiesCount的前缀和数组candieSumCount用于表示第i类糖果前所有糖果的数量和。 其次，要注意题目是从第0天开始吃糖的，我们计算时都是从第一天开始计算的，所以需要把特定时间+1。 计算吃到第t类糖果的 [最早/最晚] 时间： 最早时间（吃到第一颗favoriteType糖的最早时间）：以最大速率dailyCap吃糖，吃掉favoriteType类之前所有糖果的时间向下取整并加1： \\lfloor \\frac{candiesSumCount[favoriteType]}{dailyCap} \\rfloor + 1 最晚时间：(吃完最后一颗favoriteType糖的最晚时间)：以最小速率1吃糖，吃掉所有 favoriteType类糖的时间: candiesSumCount[favoriteType+1] 代码： 1234567891011121314151617181920212223class Solution &#123; public boolean[] canEat(int[] candiesCount, int[][] queries) &#123; boolean[] answer = new boolean[queries.length]; //前缀和数组，使用long防止溢出 long[] candiesSumCount = new long[candiesCount.length+1]; //计算想要吃到指定类型的糖之前需要吃的糖的数量 for (int i = 1; i &lt;= candiesCount.length; i++) &#123; candiesSumCount[i] = candiesSumCount[i-1]+candiesCount[i-1]; &#125; for (int i = 0; i &lt; queries.length; i++) &#123; int favoriteType = queries[i][0]; //因为后续计算是从第1天开始的，所以将题目设定的时间加1 int favoriteDay = queries[i][1]+1; int dailyCap = queries[i][2]; //计算能吃到糖的最早时间=以最大速率吃完前面的糖的时间（向下取整）+1 long min = candiesSumCount[favoriteType] / dailyCap + 1; //能吃到糖的最晚时间=吃光喜欢的糖需要的时间 long max = candiesSumCount[favoriteType+1]; answer[i] = favoriteDay&gt;=min &amp;&amp; favoriteDay&lt;=max; &#125; return answer; &#125;&#125; 时间复杂度：$O(n+m)$，candiesSum的数组长度为n, queries的数组长度为m 空间复杂度：$O(n)$","categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-05T13:13:45.237Z","updated":"2021-06-05T13:13:45.237Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"http://example.com/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]}