{"meta":{"title":"Ashen One","subtitle":"Days of our life","description":"","author":"Ashen One","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-31T18:51:16.462Z","updated":"2021-03-31T18:51:16.456Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-31T18:51:02.420Z","updated":"2021-03-31T18:51:02.416Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【LeetCode每日题解】20210606","slug":"【LeetCode每日题解】20210606","date":"2021-06-10T20:51:24.238Z","updated":"2021-06-10T20:46:29.000Z","comments":true,"path":"posts/a985094a/","link":"","permalink":"http://example.com/posts/a985094a/","excerpt":"","text":"【LeetCode每日题解】20210606【每日一题】474. 一和零链接：https://leetcode-cn.com/problems/ones-and-zeroes/ 题目： 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 思路： 首先需要将这题抽象为背包问题，strs中每个字符串的价值都为1，选择的成本是字符串中0的数量和1的数量。每个字符串只能选择一次，可以选择放或者不放，要求其总价值最大，符合01背包问题的定义。01背包问题的状态转移方程为： f[i][v]=max({f[i-1][v],f[i-1][v-c[i]]+w[i]})其中v维度代表当前最大的成本（代价），由于这题影响成本的有两个因素0的数量和1的数量，所以需要增加一个维度。 状态定义为：$f[k][i][k]$代表考虑前k件物品，在数字1不超过容量i，数字0不超过容量j的条件下，所能达到的最大价值（最大的字符串数量）。 修改后的状态转移方程如下： f[k][i][j]=max(f[k−1][i][j],f[k−1][i−cnt[k][0]][j−cnt[k][1]]+1)其中$cnt[]$数组记录的是字符串中0，1出现的数量。 代码： 动态规划 1234567891011121314151617181920212223class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; int length = strs.length; int[][][] dp = new int[length+1][m+1][n+1]; for (int i = 1; i &lt;= length; i++) &#123; //对每个字符串中1，0的数量进行统计 int zeroCount=0,oneCount=0; for (char c: strs[i-1].toCharArray()) &#123; if(c==&#x27;1&#x27;)oneCount++; else zeroCount++; &#125; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k &lt;= n; k++) &#123; dp[i][j][k] = dp[i-1][j][k]; if(j&gt;=zeroCount &amp;&amp; k&gt;=oneCount)&#123; dp[i][j][k] = Math.max(dp[i][j][k],dp[i-1][j-zeroCount][k-oneCount]+1); &#125; &#125; &#125; &#125; return dp[length][m][n]; &#125;&#125; 空间复杂度：O(k*m*n) 时间复杂度：O(k * m * n) 根据状态转移方程，更新某个物体的状态时，只依赖于上一个物体的状态，还明确依赖于比j小和比k小的状态，所以可以使用[01背包的空间优化方式]，去掉物品维度。 123456789101112131415161718192021class Solution &#123; public int findMaxForm2(String[] strs, int m, int n) &#123; int length = strs.length; //去掉了物品维度 int[][] dp = new int[m+1][n+1]; for (int i = 1; i &lt;= length; i++) &#123; int zeroCount=0,oneCount=0; for (char c: strs[i-1].toCharArray()) &#123; if(c==&#x27;1&#x27;)oneCount++; else zeroCount++; &#125; //倒序遍历，这样能保证每次修改的都是上一个物品的状态。 for (int j = m; j &gt;= zeroCount; j--) &#123; for (int k = n; k &gt;= oneCount; k--) &#123; dp[j][k] = Math.max(dp[j][k],dp[j-zeroCount][k-oneCount]+1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 时间复杂度：$O(kmn)$ 空间复杂度：$O(m*n)$ 【动态规划 01背包问题】416. 分割等和子集链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/ 题目： 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 思路： 1234graph TD 题目[题目: 将数值分为两个子集,子集的和相等] --&gt; |等效|等效[从数组中挑选若干个元素,使得元素总和等于所有元素总和的一半] --&gt; |转化为背包问题|背包问题[背包容量为 target&#x3D;sum&#x2F;2,每个数组元素的价值与成本都是其数值大小,求我们能否装满背包] 上图展示了如何将题目转化为背包问题。由于每个数字只能选取一次，求解是最大价值，所以可以使用01背包的模型。 状态定义：f[i][j]代表考虑前i个数值，其数字总和不超过j的最大价值（数值大小）。 状态转移方程：每个数字都可以选或者不选。f[i][j]=max(f[i-1][j],f[i-1][j-nums[i]]+nums[i]) 代码： 基本解法 1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0,length = nums.length,maxNum = 0; for (int n: nums) &#123; sum+=n; maxNum = Math.max(maxNum,n); &#125; //不可能分割为两个等和数组的情况 if(length &lt; 2 || sum % 2 != 0 || maxNum &gt; sum/2) return false; int maxCapcity = sum / 2; int target = maxCapcity; int[][] dp = new int[length][maxCapcity+1]; //dp数组初始化 for (int i = 0; i &lt;= target; i++) &#123; dp[0][i] = i &gt;= nums[0] ? nums[0]:0; &#125; for (int i = 1; i &lt; length; i++) &#123; int t = nums[i]; for (int j = 0; j &lt;= maxCapcity; j++) &#123; //不选择第i个数字 int no = dp[i-1][j]; //选择第i个数字 int yes = j &gt;= t ? dp[i-1][j-t]+t : 0; dp[i][j] = Math.max(no,yes); //一旦有状态等于target就可以返回true if(dp[i][j]==target)return true; &#125; &#125; return false; &#125;&#125; 时间复杂度：$O(n+m)$ 空间复杂度：$O(n)$ 一维空间优化 12345678910111213141516171819202122232425262728293031public boolean canPartition2(int[] nums) &#123; int sum = 0,length = nums.length,maxNum = 0; for (int n: nums) &#123; sum+=n; maxNum = Math.max(maxNum,n); &#125; //不可能分割为两个等和数组的情况 if(length &lt; 2 || sum % 2 != 0 || maxNum &gt; sum/2) return false; int maxCapcity = sum / 2; int target = maxCapcity; //去除物品维度 int[] dp = new int[maxCapcity+1]; //dp数组初始化 for (int i = 0; i &lt;= target; i++) &#123; dp[i] = i &gt;= nums[0] ? nums[0]:0; &#125; for (int i = 1; i &lt; length; i++) &#123; int t = nums[i]; //倒序遍历 for (int j = maxCapcity; j &gt;= 0; j--) &#123; //不选择第i个数字 int no = dp[j]; //选择第i个数字 int yes = j &gt;= t ? dp[j-t]+t : 0; dp[j] = Math.max(no,yes); if(dp[j]==target)return true; &#125; &#125; return false; &#125; 时间复杂度：O(n∗target)空间复杂度：O(target)","categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]},{"title":"【LeetCode每日题解】20210607","slug":"【LeetCode每日题解】20210607","date":"2021-06-07T18:19:42.636Z","updated":"2021-06-07T18:19:42.636Z","comments":true,"path":"posts/de8239dc/","link":"","permalink":"http://example.com/posts/de8239dc/","excerpt":"","text":"【LeetCode每日题解】20210607【每日一题】494. 目标和链接：https://leetcode-cn.com/problems/target-sum/ 题目： 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 思路：这题要求所有满足要求的表达式的数目，可以采用回溯的方法。 代码： 回溯法 12345678910111213141516171819202122class Solution &#123; public class LC494 &#123; public int res=0; public int findTargetSumWays(int[] nums, int target) &#123; int level = nums.length; res = 0; dfs(nums,level,0,target,0); return res; &#125; private void dfs(int[] nums, int level, int currentLevel,int target ,int currentSum)&#123; //判断递归结束条件 if(currentLevel==level)&#123; if(currentSum == target)res++; return; &#125; //给当前数字赋&quot;+&quot;号 dfs(nums,level,currentLevel+1,target,currentSum+nums[currentLevel]); //给当前数字赋&quot;-&quot;号 dfs(nums,level,currentLevel+1,target,currentSum-nums[currentLevel]); &#125; &#125;&#125; 动态规划（全量） 12345678910111213141516171819class Solution &#123; public int findMaxForm2(String[] strs, int m, int n) &#123; int length = strs.length; int[][] dp = new int[m+1][n+1]; for (int i = 1; i &lt;= length; i++) &#123; int zeroCount=0,oneCount=0; for (char c: strs[i-1].toCharArray()) &#123; if(c==&#x27;1&#x27;)oneCount++; else zeroCount++; &#125; for (int j = m; j &gt;= zeroCount; j--) &#123; for (int k = n; k &gt;= oneCount; k--) &#123; dp[j][k] = Math.max(dp[j][k],dp[j-zeroCount][k-oneCount]+1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ 总结：","categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]},{"title":"【LeetCode每日题解】20210605","slug":"【LeetCode每日题解】20210605","date":"2021-06-05T16:10:12.612Z","updated":"2021-06-05T16:10:12.612Z","comments":true,"path":"posts/308c58f0/","link":"","permalink":"http://example.com/posts/308c58f0/","excerpt":"","text":"【LeetCode每日题解】20210605【每日一题】203. 移除链表元素链接：https://leetcode-cn.com/problems/remove-linked-list-elements/ 题目：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 思路：移除链表中的节点可以通过递归和迭代的方式求解。利用dummy节点可以解决头节点被删除的情况。 代码： 迭代法实现 1234567891011121314class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode currentNode = dummy; while(currentNode.next!=null)&#123; if(currentNode.next.val == val)&#123; currentNode.next = currentNode.next.next; &#125; else currentNode = currentNode.next; &#125; return dummy.next; &#125;&#125; 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ 总结：除了迭代法外，这题还可以通过递归的方式删除链表中的节点。 【前缀和】1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/ 题目： 给你一个下标从 0 开始的正整数数组 candiesCount，其中 candiesCount[i] 表示你拥有的第i类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 思路： 要判断是否能在满足吃糖数量的限制条件的情况下在特定日期吃到特定种类的糖，需要利用吃糖数量的限制计算出吃到特定种类糖的最早/最晚时间，再判断特定日期是否在区间内即可。 首先，为了方便计算，需要预处理出candiesCount的前缀和数组candieSumCount用于表示第i类糖果前所有糖果的数量和。 其次，要注意题目是从第0天开始吃糖的，我们计算时都是从第一天开始计算的，所以需要将特定时间+1。 计算吃到第t类糖果的 [最早/最晚] 时间： 最早时间（吃到第一颗favoriteType糖的最早时间）：以最大速率dailyCap吃糖，吃掉favoriteType类之前所有糖果的时间向下取整并加1： \\lfloor \\frac{candiesSumCount[favoriteType]}{dailyCap} \\rfloor + 1 最晚时间：(吃完最后一颗favoriteType糖的最晚时间)：以最小速率1吃糖，吃掉所有 favoriteType类糖的时间: candiesSumCount[favoriteType+1] 代码： 1234567891011121314151617181920212223class Solution &#123; public boolean[] canEat(int[] candiesCount, int[][] queries) &#123; boolean[] answer = new boolean[queries.length]; //前缀和数组，使用long防止溢出 long[] candiesSumCount = new long[candiesCount.length+1]; //计算想要吃到指定类型的糖之前需要吃的糖的数量 for (int i = 1; i &lt;= candiesCount.length; i++) &#123; candiesSumCount[i] = candiesSumCount[i-1]+candiesCount[i-1]; &#125; for (int i = 0; i &lt; queries.length; i++) &#123; int favoriteType = queries[i][0]; //因为后续计算是从第1天开始的，所以将题目设定的时间加1 int favoriteDay = queries[i][1]+1; int dailyCap = queries[i][2]; //计算能吃到糖的最早时间=以最大速率吃完前面的糖的时间（向下取整）+1 long min = candiesSumCount[favoriteType] / dailyCap + 1; //能吃到糖的最晚时间=吃光喜欢的糖需要的时间 long max = candiesSumCount[favoriteType+1]; answer[i] = favoriteDay&gt;=min &amp;&amp; favoriteDay&lt;=max; &#125; return answer; &#125;&#125; 时间复杂度：$O(n+m)$，candiesSum的数组长度为n, queries的数组长度为m 空间复杂度：$O(n)$","categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-05T13:13:45.237Z","updated":"2021-06-05T13:13:45.237Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"http://example.com/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/categories/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LeetCode每日题解","slug":"LeetCode每日题解","permalink":"http://example.com/tags/LeetCode%E6%AF%8F%E6%97%A5%E9%A2%98%E8%A7%A3/"}]}