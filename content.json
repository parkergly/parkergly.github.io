{"meta":{"title":"Ashen One","subtitle":"Days of our life","description":"","author":"Ashen One","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-31T18:51:16.462Z","updated":"2021-03-31T18:51:16.456Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-31T18:51:02.420Z","updated":"2021-03-31T18:51:02.416Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode刷题笔记20210407","slug":"LeetCode刷题笔记20210407","date":"2021-04-07T14:00:00.000Z","updated":"2021-04-08T08:55:12.000Z","comments":true,"path":"2021/04/07/LeetCode刷题笔记20210407/","link":"","permalink":"http://example.com/2021/04/07/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210407/","excerpt":"","text":"102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 思路：二叉树的层序遍历通常使用广度优先搜索，广度优先搜索的关键在于利用队列FIFO的特点记录待遍历的节点，利用currentLevelSize变量记录当前层的节点数量，利用currentLevel变量存放当前层的节点。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; List&lt;Integer&gt; currentLevel = new ArrayList&lt;Integer&gt;(); int currentLevelSize = queue.size(); for (int i = 0; i &lt; currentLevelSize; i++) &#123; TreeNode node = queue.poll(); currentLevel.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; res.add(currentLevel); &#125; return res; &#125;&#125; 107. 二叉树的层序遍历 II给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 思路：本题要求自底向上层序遍历，利用ArrayList的方法，将遍历到的每层节点插入List的头部即可。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; List&lt;Integer&gt; currentLevel = new ArrayList&lt;Integer&gt;(); int currentLevelSize = queue.size(); for (int i = 0; i &lt; currentLevelSize; i++) &#123; TreeNode node = queue.poll(); currentLevel.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; res.add(0,currentLevel); &#125; return res; &#125;&#125; 103. 二叉树的锯齿形层序遍历给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 思路：利用isOrderLeft标志位记录当前遍历方向，利用Deque双向队列的offerLast和offerFirst方法分别在尾部和头部进行插入。 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); //设置方向标志位 boolean isOrderLeft = true; while(!queue.isEmpty())&#123; Deque&lt;Integer&gt; currentLevel = new LinkedList&lt;Integer&gt;(); int currentLevelSize = queue.size(); for (int i = 0; i &lt; currentLevelSize; i++) &#123; TreeNode node = queue.poll(); if(isOrderLeft) currentLevel.offerLast(node.val); else currentLevel.offerFirst(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; res.add(new LinkedList&lt;Integer&gt;(currentLevel)); isOrderLeft = !isOrderLeft; &#125; return res; &#125;&#125; 994. 腐烂的橘子在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 思路：一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int orangesRotting(int[][] grid) &#123; /* 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。 然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。 由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子 */ int row = grid.length; int col = grid[0].length; Queue&lt;int[]&gt; positions = new LinkedList&lt;int[]&gt;(); int freshOrangeCount = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if(grid[i][j] == 1) freshOrangeCount++; else if(grid[i][j] == 2) positions.add(new int[]&#123;i,j&#125;); &#125; &#125; if(freshOrangeCount == 0)return 0; int minutes = 0; while(!positions.isEmpty())&#123; int currentsize = positions.size(); for (int i = 0; i &lt; currentsize; i++) &#123; int[] position = positions.poll(); int x = position[0]; int y = position[1]; if(grid[x][y] == 1) &#123; freshOrangeCount--; if(freshOrangeCount == 0)return minutes; grid[x][y] = 2; &#125; //上下左右 if(y-1 &gt;=0 &amp;&amp; grid[x][y-1] == 1) positions.offer(new int[]&#123;x,y-1&#125;); if(x-1 &gt;=0 &amp;&amp; grid[x-1][y] == 1) positions.offer(new int[]&#123;x-1,y&#125;); if(y+1 &lt; col &amp;&amp; grid[x][y+1] == 1) positions.offer(new int[]&#123;x,y+1&#125;); if(x+1 &lt; row &amp;&amp; grid[x+1][y] == 1) positions.offer(new int[]&#123;x+1,y&#125;); &#125; minutes++; &#125; if(freshOrangeCount!=0)return -1; return minutes; &#125;&#125; 127. 单词接龙字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列： 序列中第一个单词是 beginWord 。 序列中最后一个单词是 endWord 。 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典 wordList 中的单词。 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。 思路：已知目标顶点的情况下，可以分别从起点和目标顶点（终点）执行广度优先遍历，直到遍历的部分有交集。这种方式搜索的单词数量会更小一些；更合理的做法是，每次从单词数量小的集合开始扩散；这里 beginVisited 和 endVisited 交替使用，等价于单向 BFS 里使用队列，每次扩散都要加到总的 visited 里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; //先将wordList放入哈希表中，以便于判断某个单词是否在wordlist中 Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); if(wordList.size() == 0 || !wordSet.contains(endWord))return 0; //将访问过的word添加到visited哈希表中 Set&lt;String&gt; visited = new HashSet&lt;&gt;(); //分别用左边和右边扩散的哈希表代替单向BFS里的队列，它们在双向BFS的过程中交替使用 Set&lt;String&gt; beginVisited = new HashSet&lt;&gt;(); beginVisited.add(beginWord); Set&lt;String&gt; endVisited = new HashSet&lt;&gt;(); endVisited.add(endWord); //执行双向BFS，左右交替扩散的步数之和为所求 int step =1; while (!beginVisited.isEmpty() &amp;&amp; !endVisited.isEmpty())&#123; //优先选择更小的哈希表进行扩散 if(beginVisited.size() &gt; endVisited.size())&#123; Set&lt;String&gt; temp = beginVisited; beginVisited = endVisited; endVisited = temp; &#125; Set&lt;String&gt; nextLevelVisited = new HashSet&lt;&gt;(); for (String word: beginVisited) &#123; for(String word2: wordList)&#123; if(isChangeable(word,word2))&#123; if(endVisited.contains(word2))return step + 1; if(!visited.contains(word2))&#123; visited.add(word2); nextLevelVisited.add(word2); &#125; &#125; &#125; &#125; beginVisited = nextLevelVisited; step++; &#125; return 0; &#125; private boolean isChangeable(String word1,String word2)&#123; int count = 0; for (int i = 0; i &lt; word1.length(); i++) &#123; if(word1.charAt(i) != word2.charAt(i))count++; &#125; if(count&gt;=2 || count == 0) return false; return true; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"LeetCode刷题笔记20210406","slug":"LeetCode刷题笔记20210406","date":"2021-04-06T14:00:00.000Z","updated":"2021-04-07T05:16:33.000Z","comments":true,"path":"2021/04/06/LeetCode刷题笔记20210406/","link":"","permalink":"http://example.com/2021/04/06/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210406/","excerpt":"","text":"129. 求根节点到叶节点数字之和给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。计算从根节点到叶节点生成的 所有数字之和 。 叶节点 是指没有子节点的节点。 链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers 思路：对于每个叶子节点而言，应该都要返回一个当前路径对应的数字，对于非叶子节点而言，应该将其左子树和右子树返回的路径和相加（在return中实现）。每次递归需要传递当前路径的数字排列，所以需要number变量传递。 123456789101112131415class Solution &#123; public int sumNumbers(TreeNode root) &#123; return DFS(root,0); &#125; private int DFS(TreeNode node, int number)&#123; //判断递归退出条件 if(node == null) return 0; //构造当前节点的路径和 number = number * 10 + node.val; //若为叶子节点则加上当前路径和 if(node.left == null &amp;&amp; node.right == null) return number; //递归执行 return DFS(node.left,number) + DFS(node.right, number); &#125;&#125; 199. 二叉树的右视图给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view 思路：利用深度优先搜索，优先遍历右子树，利用rightViewNum的大小来记录当前右视图的最大深度。 12345678910111213class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; rightViewNum = new ArrayList&lt;Integer&gt;(); DFS(root,rightViewNum,1); return rightViewNum; &#125; private void DFS(TreeNode node, List&lt;Integer&gt; rightViewNum, int height) &#123; if(node == null) return; if(height &gt; rightViewNum.size()) rightViewNum.add(node.val); DFS(node.right, rightViewNum, height+1); DFS(node.left, rightViewNum, height+1); &#125;&#125; 695. 岛屿的最大面积给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)链接：https://leetcode-cn.com/problems/max-area-of-island思路：利用visited数组记录已经访问过的节点（也可以通过将访问过的节点置零（沉岛法）），对于每一个未访问过的节点进行深度优先搜索（分别对四个方向进行深度优先搜索，并标记访问过的节点）。利用area统计当前岛屿的总大小，每个岛屿遍历结束后与maxArea进行比较。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int rows = grid.length; int cols = grid[0].length; int maxArea = 0; boolean[][] visited = new boolean[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if(visited[i][j] != true &amp;&amp; grid[i][j] != 0)&#123; int area = DFS(visited,grid,i,j); maxArea = Math.max(area, maxArea); &#125; &#125; &#125; return maxArea; &#125; private int DFS(boolean[][] visited, int[][] grid, int row, int col) &#123; //判断递归退出条件，1.数组越界，2.该位置为0，3.该点已访问过。 int rows = grid.length; int cols = grid[0].length; if(row &gt;= rows || row &lt;0 || col &gt;= cols || col &lt; 0) return 0; if(grid[row][col] == 0 || visited[row][col] == true) return 0; //找到新的节点，1.将visited置为true，2.递归寻找下一个节点（向下，向右）。 visited[row][col] = true; int area = 1; area += DFS(visited,grid,row,col+1); area += DFS(visited,grid,row,col-1); area += DFS(visited,grid,row+1,col); area += DFS(visited,grid,row-1,col); return area; &#125;&#125; 200. 岛屿数量给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。链接：https://leetcode-cn.com/problems/number-of-islands思路：利用visited数组记录已经访问过的节点（也可以通过将访问过的节点置零（沉岛法）），对于每一个未访问过的节点进行深度优先搜索（分别对四个方向进行深度优先搜索，并标记访问过的节点）。利用count统计访问过的每个岛屿的第一个节点。 12345678910111213141516171819202122232425262728293031class Solution &#123; public int numIslands(char[][] grid) &#123; int rows = grid.length; int cols = grid[0].length; int count = 0; boolean[][] visited = new boolean[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if(visited[i][j] != true &amp;&amp; grid[i][j] != &#x27;0&#x27;)&#123; DFS(visited,grid,i,j); count++; &#125; &#125; &#125; return count; &#125; private void DFS(boolean[][] visited, char[][] grid, int row, int col) &#123; //判断递归退出条件，1.数组越界，2.该位置为0，3.该点已访问过。 int rows = grid.length; int cols = grid[0].length; if(row &gt;= rows || row &lt;0 || col &gt;= cols || col &lt; 0) return; if(grid[row][col] == &#x27;0&#x27; || visited[row][col] == true) return; //找到新的节点，1.将visited置为true，2.递归寻找下一个节点（向下，向右）。 visited[row][col] = true; DFS(visited,grid,row,col+1); DFS(visited,grid,row,col-1); DFS(visited,grid,row+1,col); DFS(visited,grid,row-1,col); &#125;&#125; 100. 相同的树给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 思路：利用DFS遍历每个节点，对比节点是否一致。 12345678class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; //判断退出条件 if(p == null &amp;&amp; q == null)return true; if(p == null || q == null || p.val != q.val)return false; else return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125;&#125; 124. 二叉树中的最大路径和路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum思路：因为要记录所有路径中的最大路径和，所以需要一个全局变量maxSum进行统计，初始值设置为Integer.MIN_VALUE。对根节点进行DFS，对于每一个节点父节点而言，其子节点的最大路径和必定是从一个子树路径而来的，所以return的时候是子节点+max（子节点的左子树路径和，右子树路径和），当路径和为负数时，返回值为0，即代表放弃其子节点的相关路径。对于maxSum而言，其最大值就是当前节点的值加上其左右子树的路径和（最小值为0）。 123456789101112131415class Solution &#123; int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; maxSum = Integer.MIN_VALUE; dfs(root); return maxSum; &#125; private int dfs(TreeNode root) &#123; if(root == null) return 0; int leftSum = dfs(root.left); int rightSum = dfs(root.right); maxSum = Math.max(maxSum, leftSum + rightSum + root.val); return Math.max(0,Math.max(leftSum,rightSum)+ root.val); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"LeetCode刷题笔记20210404","slug":"LeetCode刷题笔记20210404","date":"2021-04-04T14:39:55.000Z","updated":"2021-04-05T01:14:01.000Z","comments":true,"path":"2021/04/04/LeetCode刷题笔记20210404/","link":"","permalink":"http://example.com/2021/04/04/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B020210404/","excerpt":"","text":"108. 将有序数组转换为二叉搜索树给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过 1 的二叉树。 思路：通过递归不断组建左右子树，每次递归都将（left + right）/ 2 作为根节点（中点），通过递归获得其左右子树，最终完成高度平衡的二叉搜索树。 123456789101112131415class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; return buildBST(nums, 0,nums.length-1); &#125; private TreeNode buildBST(int[] nums, int left, int right) &#123; //判断递归结束条件 if(left &gt; right) return null; //构建当前子树 int mid = (left + right) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = buildBST(nums, left, mid - 1); root.right = buildBST(nums, mid + 1, right); return root; &#125;&#125; 98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 思路：由于二叉搜索树的中序遍历是严格递增的，只需要列出给定的二叉树的中序遍历，并判断其是否递增即可。利用preNodeValue记录上个节点的值。 1234567891011121314class Solution &#123; long preNodeValue = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) &#123; if(root == null) return true; //访问左子树 if(!isValidBST(root.left)) return false; //访问当前节点，与中序遍历的前一个节点比较， if(root.val &lt;= preNodeValue) return false; //更新preNodeValue的值 preNodeValue = root.val; //访问右子树 return isValidBST(root.right); &#125;&#125; 110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 思路：通过递归计算左右子树的高度，从下往上进行计算，并判断左右子树是否符合高度平衡的要求。 123456789101112131415class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return height(root) != -1; &#125; private int height(TreeNode root) &#123; //递归结束条件,当前节点为空 if(root == null) return 0; //先递归判断左右子树是否平衡 int leftHeight = height(root.left); int rightHeight = height(root.right); if(leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) return -1; //再返回当前节点高度 return Math.max(leftHeight,rightHeight) + 1; &#125;&#125; 112. 路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 叶子节点 是指没有子节点的节点。 思路：利用深度优先搜索的思想，通过递归找到叶子结点，并计算路径和是否符合要求，在每次递归过程中要维护剩余路径和。 12345678class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null) return false; //判读是否为叶子节点 if(root.left == null &amp;&amp; root.right == null)&#123;return targetSum == root.val;&#125; return hasPathSum(root.left,targetSum - root.val)||hasPathSum(root.right,targetSum - root.val); &#125;&#125; 114. 二叉树展开为链表给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 思路：先通过先序遍历得到先序遍历的节点List，然后用循环修改其左右子树的指向。 12345678910111213141516171819class Solution &#123; public void flatten(TreeNode root) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;(); preOrder(root,list); int size = list.size(); for (int i = 0; i &lt; size - 1; i++) &#123; TreeNode current = list.get(i),next= list.get(i+1); current.left = null; current.right = next; &#125; &#125; private void preOrder(TreeNode root, List&lt;TreeNode&gt; list)&#123; if(root != null)&#123; list.add(root); preOrder(root.left, list); preOrder(root.right, list); &#125; &#125;&#125; 144. 二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 思路：利用递归完成前序遍历，根→左→右 123456789101112131415//递归解法class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; preOrder = new ArrayList&lt;Integer&gt;(); preOrderTraversal(root, preOrder); return preOrder; &#125; private void preOrderTraversal(TreeNode root, List&lt;Integer&gt; preOrder)&#123; if(root != null)&#123; preOrder.add(root.val); preOrderTraversal(root.left,preOrder); preOrderTraversal(root.right,preOrder); &#125; &#125;&#125; 1//迭代解法 94. 二叉树的中序遍历给定一个二叉树的根节点 root ，返回它的 中序 遍历。 思路：利用递归完成前序遍历，左→根→右 12345678910111213141516//递归解法class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; inorder = new ArrayList&lt;Integer&gt;(); inorderTraversal(root, inorder); return inorder; &#125; private void inorderTraversal(TreeNode root, List&lt;Integer&gt; inorder)&#123; if(root != null)&#123; inorderTraversal(root.left, inorder); inorder.add(root.val); inorderTraversal(root.right, inorder); &#125; &#125;&#125; 1//迭代解法 145. 二叉树的后序遍历给定一个二叉树的根节点 root ，返回它的 后序 遍历。 思路：利用递归完成前序遍历，左→右→根 12345678910111213141516//递归解法class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; postorder = new ArrayList&lt;Integer&gt;(); postorderTraversal(root, postorder); return postorder; &#125; private void postorderTraversal(TreeNode root, List&lt;Integer&gt; postorder)&#123; if(root != null)&#123; postorderTraversal(root.left, postorder); postorderTraversal(root.right, postorder); postorder.add(root.val); &#125; &#125;&#125; 1//迭代解法","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"LeetCode刷题笔记","slug":"LeetCode刷题笔记","date":"2021-04-02T11:42:10.000Z","updated":"2021-04-02T11:52:25.000Z","comments":true,"path":"2021/04/02/LeetCode刷题笔记/","link":"","permalink":"http://example.com/2021/04/02/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数组LC. 59 螺旋矩阵Ⅱ 简介：给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 技巧：directions二维数组来代表方向的变化，通过directionIndex来控制 123456789101112131415161718192021public int[][] generateMatrix(int n) &#123; int maxNum=n*n; int curNum = 1; int[][] matrix = new int[n][n]; int row = 0, column = 0; int[][] directions = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; int directionIndex = 0; while(curNum &lt;= maxNum)&#123; matrix[row][column] = curNum; curNum++; //调整方向 int nextRow = row + directions[directionIndex][0]; int nextColumn = column + directions[directionIndex][1]; if(nextRow &gt;= n || nextRow &lt; 0 || nextColumn &gt;= n || nextColumn &lt; 0 || matrix[nextRow][nextColumn] != 0)&#123; directionIndex = (directionIndex + 1) % 4; &#125; row = row + directions[directionIndex][0]; column = column + directions[directionIndex][1]; &#125; return matrix;&#125; LC.54 螺旋矩阵 简介：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 技巧：使用辅助矩阵visited来判断某个位置是否被访问过，visited数组的类型应为布尔值，要对程序的输入做异常判断。 12345678910111213141516171819202122232425public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; order = new ArrayList&lt;Integer&gt;(); if(matrix == null || matrix.length == 0 || matrix[0].length == 0)&#123; return order; &#125; //获取二维数组的行和列 int rows = matrix.length, columns = matrix[0].length; int[][] visited = new int[rows][columns]; int[][] directions = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; int directionIndex = 0; int maxNum = rows * columns; int curNum = 1; int curRow = 0, curColumn = 0; while(curNum &lt;= maxNum)&#123; curNum++; order.add(matrix[curRow][curColumn]); visited[curRow][curColumn] = 1; int nextRow = curRow + directions[directionIndex][0], nextColumn = curColumn + directions[directionIndex][1]; if(nextRow &gt;= rows || nextRow &lt; 0 || nextColumn &gt;= columns || nextColumn &lt; 0 || visited[nextRow][nextColumn] == 1) directionIndex = (directionIndex + 1) % 4; curRow = curRow + directions[directionIndex][0]; curColumn = curColumn + directions[directionIndex][1]; &#125; return order;&#125; LC.11 乘最多水的容器 简介：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水链接：https://leetcode-cn.com/problems/container-with-most-water 技巧：利用双指针，left&amp;right，滑动判断最大面积。 123456789101112131415public int maxArea(int[] height) &#123; int maxRes = 0; int leftIndex = 0, rightIndex = height.length - 1; while(leftIndex &lt; rightIndex)&#123; int curRes = (rightIndex - leftIndex) * Math.min(height[leftIndex],height[rightIndex]); maxRes = Math.max(maxRes, curRes); if(height[leftIndex] &lt;= height[rightIndex])&#123; leftIndex++; &#125; else&#123; rightIndex--; &#125; &#125; return maxRes; &#125; JZ.04 二维数组中的查找 简介：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof思路：从右上角开始判断。 123456789101112131415161718public boolean findNumberIn2DArray(int[][] matrix,int target)&#123; if(matrix == null || matrix.length == 0 || matrix[0].length == 0)return false; boolean res = false; int j = matrix[0].length - 1, i = 0; while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; matrix.length &amp;&amp; j &lt;matrix[0].length)&#123; if(matrix[i][j] == target)&#123; res = true; break; &#125; else if(matrix[i][j] &lt; target)&#123; i++; &#125; else&#123; j--; &#125; &#125; return res;&#125; LC.73 矩阵置零 简介：给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**原地算法。** 思路：利用额外空间记录为0的行号和列号，再统一置零。 12345678910111213141516171819public void setZeros(int[][] matrix)&#123; boolean[] flagedRows = new boolean[matrix.length]; boolean[] flagedCols = new boolean[matrix[0].length]; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; if(matrix[i][j] == 0)&#123; flagedRows[i] = true; flagedCols[j] = true; &#125; &#125; &#125; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; if(flagedRows[i] || flagedCols[j])&#123; matrix[i][j] = 0; &#125; &#125; &#125;&#125; LC48. 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 思路：通过先水平翻转，再沿主对角线翻转的方式实现90度旋转。 1234567891011121314151617181920public void rotate(int[][] matrix) &#123; int rows = matrix.length; int cols = rows; //水平翻转 for (int i = 0; i &lt; rows/2; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[rows-1-i][j]; matrix[rows-1-i][j] = temp; &#125; &#125; //沿左对角线翻转 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125;&#125; 动态规划LC.115不同的子序列 简介：给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）链接：https://leetcode-cn.com/problems/distinct-subsequences 1234567891011121314151617181920212223242526272829public static int numDistinct(String s, String t)&#123; if (s.length() &lt; t.length()) return 0; int[][] dp = new int[t.length()+1][s.length()+1]; //dp初始化 for(int i = 0; i &lt;= t.length(); i++)&#123; for(int j = 0; j &lt;= s.length(); j++)&#123; dp[i][j] = 0; &#125; &#125; for(int j = 0; j &lt;= s.length(); j++)&#123; dp[0][j] = 1; &#125; //printMatrix(dp); for(int i = 1; i &lt;= t.length(); i++)&#123; for(int j = 1; j &lt;= s.length(); j++)&#123; if(s.charAt(j-1) == t.charAt(i-1))&#123; dp[i][j] = dp[i-1][j-1] + dp[i][j-1]; &#125; else&#123; dp[i][j] = dp[i][j - 1]; &#125; &#125; //printMatrix(dp); &#125; //printMatrix(dp); return dp[t.length()][s.length()]; &#125; LC.53 最大子序和 简介：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 思路：一维动态规划 12345678public int maxSubArray(int[] nums) &#123; int maxSum = nums[0]; for(int i=1; i&lt;nums.length; i++)&#123; nums[i] = Math.max(nums[i], nums[i - 1] + nums[i]); maxSum = Math.max(maxSum, nums[i]); &#125; return maxSum;&#125; LC.62不同路径 简介：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？链接：https://leetcode-cn.com/problems/unique-paths 思路：动态规划 12345678910111213141516public int uniquePaths(int m, int n) &#123; if(m == 1 || n == 1) return 1; int[][] dp = new int[m][n]; for(int i = 0; i&lt; m; i++)&#123; for(int j = 0; j&lt;n;j++)&#123; if(j==0 || i==0)dp[i][j]=1; else dp[i][j] = 0; &#125; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j&lt;n ;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125; LC.63不同路径 II 简介：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 思路：动态规划解决，遇到障碍物时要减去减少的可能路径。 12345678910111213141516171819202122232425public static int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] rows = new int[m], cols = new int[n]; int[][] dp = new int[m][n]; for(int i = 0; i&lt; m;i ++)&#123; if(obstacleGrid[i][0] == 1) break; dp[i][0] = 1; &#125; for(int j = 0; j&lt;n;j++)&#123; if(obstacleGrid[0][j]==1)break; dp[0][j]=1; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j&lt;n ;j++)&#123; if(obstacleGrid[i][j] == 1)&#123; dp[i][j] = 0; &#125; else &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; &#125; //printMatrix(dp); return dp[m-1][n-1];&#125; LC.120 三角形最小路径和 简介：给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。链接：https://leetcode-cn.com/problems/triangle思路：运用动态规划，用二维数组记录状态，考虑好边界条件和推导式的特殊情况。 1234567891011121314151617181920public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] dp = new int[n][n]; //初始化dp dp[0][0] = triangle.get(0).get(0); for(int i = 1; i &lt; n; i++)&#123; //每行的最左测 dp[i][0] = dp[i-1][0] + triangle.get(i).get(0); for(int j = 1; j &lt; i; j++)&#123; dp[i][j] = Math.min(dp[i-1][j-1],dp[i-1][j]) + triangle.get(i).get(j); &#125; //每行的最右侧 dp[i][i] = dp[i-1][i - 1] + triangle.get(i).get(i); &#125; int minTotal = dp[n-1][0]; for(int i = 1 ;i &lt; n ;i++)&#123; minTotal = Math.min(minTotal, dp[n-1][i]); &#125; return minTotal;&#125; 链表LC.92 反转链表Ⅱ 简介：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。链接：https://leetcode-cn.com/problems/reverse-linked-list-ii 思路：考虑到头节点可能变化的链表题，可以建立dummy node 来作为虚拟头节点。链表的反转可以通过三个点完成，curNode,nextNode,nextNextNode. 先将nextNode指向curNode，再使curNode=nextnode，nextnode=nextNextNode。 123456789101112131415161718public ListNode reverseBetween(ListNode head, int left, int right)&#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt; left - 1; i++)&#123; pre = pre.next; &#125; ListNode curNode = pre.next, nextNode = curNode.next; for(int i = 0 ; i &lt; right - left; i++)&#123; ListNode nextNextNode = nextNode.next; nextNode.next = curNode; curNode = nextNode; nextNode = nextNextNode; &#125; pre.next.next=nextNode; pre.next = curNode; return dummy.next;&#125; JZ.06从尾到头打印链表 简介：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 思路：1.用栈的特性解题，2 12345678910111213public int[] reversePrint(ListNode head) &#123; int count =0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(;head != null;head = head.next)&#123; stack.add(head.val); count++; &#125; int[] res = new int[count]; for(int i = 0; i &lt; count; i++)&#123; res[i] = stack.pop(); &#125; return res;&#125; LC82删除排序链表中的重复元素 II 简介：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。返回同样按升序排列的结果链表。 思路：针对头节点可能删除的情况，采用dummy node，注意考虑链表节点是否为null（null.next会报错） 12345678910111213141516171819202122public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode preNode = dummy; ListNode currentNode = head; while(currentNode != null &amp;&amp; currentNode.next!= null)&#123; if(currentNode.next.val == currentNode.val)&#123; ListNode postNode = currentNode.next; while(postNode!= null &amp;&amp; postNode.val == currentNode.val)&#123; postNode = postNode.next; &#125; preNode.next = postNode; currentNode = postNode; &#125; else&#123; preNode = currentNode; currentNode = currentNode.next; &#125; &#125; return dummy.next;&#125; LC328奇偶列表 简介：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。链接：https://leetcode-cn.com/problems/odd-even-linked-list 思路：要考虑边界值，通过维护两个指针达到奇偶分离的效果。 123456789101112131415public ListNode oddEvenList(ListNode head) &#123; //判断特殊情况 if(head == null) return head; ListNode evenHead = head.next; ListNode oddNode = head, evenNode = evenHead; while(evenNode != null &amp;&amp; evenNode.next != null)&#123; oddNode.next = evenNode.next; evenNode.next = evenNode.next.next; oddNode = oddNode.next; evenNode = evenNode.next; &#125; oddNode.next = evenHead; return head;&#125; LC19 简介： 思路：dummy 节点 ，双指针记录倒数第n个节点 1234567891011121314//因为头节点可能被删除，所以建立dummy节点ListNode dummy = new ListNode(0, head);//建立双指针，记录倒数第n个数ListNode first = head;ListNode second = dummy;for (int i = 0; i &lt; n; ++i) &#123; first = first.next;&#125;while (first != null) &#123; first = first.next; second = second.next;&#125;second.next = second.next.next;return dummy.next; LC83.删除排序链表中的重复元素 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 思路：遍历链表即可，如有重复，将该节点从链表中移除，注意判断结束条件。 123456789101112public ListNode deleteDuplicates(ListNode head) &#123; ListNode curNode = head; while(curNode != null &amp;&amp; curNode.next != null)&#123; if(curNode.val == curNode.next.val)&#123; curNode.next = curNode.next.next; &#125; else&#123; curNode = curNode.next; &#125; &#125; return head;&#125; 栈LC150 简介：根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation思路：运用栈的思想进行运算，遇到数字放入，遇到符号计算，记住String到Int类型的转换，可以编写辅助函数简化程序。 123456789101112131415161718192021222324public static int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; for (String token: tokens) &#123; if(isNumber(token))&#123; stack.push(Integer.parseInt(token)); &#125; else&#123; int num2 = stack.pop(),num1 = stack.pop(); switch (token)&#123; case &quot;+&quot; : stack.push(num1+num2);break; case &quot;-&quot; : stack.push(num1-num2);break; case &quot;*&quot; : stack.push(num1*num2);break; case &quot;/&quot; : stack.push(num1/num2);break; default: &#125; &#125; &#125; return stack.pop();&#125;public static boolean isNumber(String s)&#123; if(s.equals(&quot;+&quot;) &amp;&amp;s.equals(&quot;-&quot;) &amp;&amp;s.equals(&quot;*&quot;) &amp;&amp;s.equals(&quot;/&quot;))return true; else return false;&#125; LC456.132模式 简介：给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false链接：https://leetcode-cn.com/problems/132-pattern思路： 1234567891011121314151617public boolean find132pattern(int[] nums) &#123; Deque&lt;Integer&gt; possibleK = new LinkedList&lt;Integer&gt;(); possibleK.push(nums[nums.length - 1]); int maxK = Integer.MIN_VALUE; for(int i = nums.length - 2; i&gt;=0; i--)&#123; if(nums[i] &lt; maxK)&#123; return true; &#125; while(!possibleK.isEmpty() &amp;&amp; nums[i] &gt; possibleK.peek())&#123; maxK = possibleK.pop(); &#125; if(nums[i] &gt; maxK)&#123; possibleK.push(nums[i]); &#125; &#125; return false;&#125; 位运算LC.191 位1的个数 简介：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 思路：n&amp;（1&lt;&lt;i） 或者 n&amp;（n-1） 123456789public int hammingWeight(int n) &#123; int res = 0; for(int i=0; i&lt;32; i++)&#123; if((n&amp;(1&lt;&lt;i)) != 0)&#123; res++; &#125; &#125; return res;&#125; 排序LC.56 合并区间 简介：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 思路：先针对左端点排序（调用sort方法并自定义比较器），再通过对比右端点合并区间， 1234567891011121314151617181920public int[][] merge(int[][] intervals) &#123; //按区间的左端点排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return o1[0] - o2[0]; &#125; &#125;); List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;(); for (int i = 0; i &lt; intervals.length; i++) &#123; int left = intervals[i][0],right = intervals[i][1]; if(merged.size() == 0 || merged.get(merged.size()-1)[1] &lt; left )&#123; merged.add(new int[]&#123;left,right&#125;); &#125; else&#123; merged.get(merged.size()-1)[1] = Math.max(right, merged.get(merged.size()-1)[1]); &#125; &#125; return merged.toArray(new int[merged.size()][]);&#125; LC148 排序链表 简介： 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 ， 思路：使用归并排序，且不使用递归的方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public ListNode sortList(ListNode head) &#123; if(head == null)&#123;return head;&#125; int length = 0; ListNode node = head; while(node != null)&#123; length++; node = node.next; &#125; ListNode dummy = new ListNode(-1 ,head); //最外层循环，控制子链表的长度 for (int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123; //两两一组，遍历目前长度下的所有子链表 ListNode curNode = dummy.next, preNode = dummy; while(curNode != null)&#123; //第一个子链表 ListNode head1 = curNode; for (int i = 1; i &lt; subLength &amp;&amp; curNode.next!= null; i++) &#123; curNode =curNode.next; &#125; //第二个子链表 ListNode head2 = curNode.next; curNode.next = null; curNode = head2; for (int i = 1; i &lt; subLength &amp;&amp; curNode != null; i++) &#123; curNode = curNode.next; &#125; //记录下剩余的链表的起始位置 ListNode next = null; if(curNode != null)&#123; next = curNode.next; curNode.next = null; &#125; //合并子链表 ListNode merged = merge(head1,head2); //将子链表重新插入原链表中 preNode.next = merged; //重新定位preNode和curNode while(preNode.next != null)&#123;preNode= preNode.next;&#125; curNode=next; &#125; &#125; return dummy.next;&#125;private ListNode merge(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode curNode = dummy; while (l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; curNode.next = l1; l1 = l1.next; &#125; else&#123; curNode.next = l2; l2 = l2.next; &#125; curNode = curNode.next; &#125; if(l1 != null) curNode.next = l1; if(l2 != null) curNode.next = l2; return dummy.next;&#125; 贪心算法55. 跳跃游戏 待做题LC969煎饼排序","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"初探反射","slug":"初探反射","date":"2021-04-02T03:18:04.000Z","updated":"2021-04-02T11:07:50.000Z","comments":true,"path":"2021/04/02/初探反射/","link":"","permalink":"http://example.com/2021/04/02/%E5%88%9D%E6%8E%A2%E5%8F%8D%E5%B0%84/","excerpt":"","text":"什么是反射？​ 反射是JAVA的特性之一，其运行JAVA程序在运行时获取类的信息，并且可以操作类或对象的内部属性。 ​ JAVA的反射机制使得程序可以在运行时动态的创建对象并调用其属性，不需要在编译期间确定对象的类型。当通过反射与一个未知类型的对象打交道时，JVM只是简单的检查这个对象，看它属于哪一个类，在用它做其他事情之前必须先加载那个类的Class对象。对于RTTI而言，编译器在编译是打开和检查.class文件。而对于反射机制来说，.class文件是在运行时被打开和检查的。 ​ JAVA的反射主要有以下几个功能： ​ 在运行时判断任意一个对象所属的类； ​ 在运行时构造任意一个类的对象； ​ 在运行时判断任意一个类所具有的成员变量； ​ 在运行时调用任意一个对象的方法； 反射的用途​ 反射最重要的用途就是开发各种通用框架。如Spring就是配置化的，需要根据配置文件加载不同的对象或类，调用不同的方法，这时候就需要用到反射，在运行时动态加载对象。 反射的基本运用​ Class类与java.lang.reflect类库一起对反射的概念进行了支持，reflect类库包含了Field、Method和Constructor类。这些类型的对象会由JVM在运行时创建，用于未知类中的成员。所以可以运用Constructor来创建新的对象，用get()和set()方法读取和修改Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。此外，还可以调用getFields()、getMethods()和getConstructors()等方法获得更多类的信息。以下是反射一些基本运用的示例：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Hexo 个人博客搭建教程","slug":"Hexo-个人博客搭建教程","date":"2021-04-01T05:41:06.000Z","updated":"2021-04-01T05:41:06.518Z","comments":true,"path":"2021/04/01/Hexo-个人博客搭建教程/","link":"","permalink":"http://example.com/2021/04/01/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-31T18:04:30.893Z","updated":"2021-03-31T18:04:30.893Z","comments":true,"path":"2021/04/01/hello-world/","link":"","permalink":"http://example.com/2021/04/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"}]}