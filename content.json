{"meta":{"title":"Ashen One","subtitle":"Days of our life","description":"","author":"Ashen One","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-31T18:51:16.462Z","updated":"2021-03-31T18:51:16.456Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-31T18:51:02.420Z","updated":"2021-03-31T18:51:02.416Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode刷题笔记","slug":"LeetCode刷题笔记","date":"2021-04-02T11:42:10.000Z","updated":"2021-04-02T11:52:25.000Z","comments":true,"path":"2021/04/02/LeetCode刷题笔记/","link":"","permalink":"http://example.com/2021/04/02/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数组LC. 59 螺旋矩阵Ⅱ 简介：给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 技巧：directions二维数组来代表方向的变化，通过directionIndex来控制 123456789101112131415161718192021public int[][] generateMatrix(int n) &#123; int maxNum=n*n; int curNum = 1; int[][] matrix = new int[n][n]; int row = 0, column = 0; int[][] directions = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; int directionIndex = 0; while(curNum &lt;= maxNum)&#123; matrix[row][column] = curNum; curNum++; //调整方向 int nextRow = row + directions[directionIndex][0]; int nextColumn = column + directions[directionIndex][1]; if(nextRow &gt;= n || nextRow &lt; 0 || nextColumn &gt;= n || nextColumn &lt; 0 || matrix[nextRow][nextColumn] != 0)&#123; directionIndex = (directionIndex + 1) % 4; &#125; row = row + directions[directionIndex][0]; column = column + directions[directionIndex][1]; &#125; return matrix;&#125; LC.54 螺旋矩阵 简介：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 技巧：使用辅助矩阵visited来判断某个位置是否被访问过，visited数组的类型应为布尔值，要对程序的输入做异常判断。 12345678910111213141516171819202122232425public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; order = new ArrayList&lt;Integer&gt;(); if(matrix == null || matrix.length == 0 || matrix[0].length == 0)&#123; return order; &#125; //获取二维数组的行和列 int rows = matrix.length, columns = matrix[0].length; int[][] visited = new int[rows][columns]; int[][] directions = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; int directionIndex = 0; int maxNum = rows * columns; int curNum = 1; int curRow = 0, curColumn = 0; while(curNum &lt;= maxNum)&#123; curNum++; order.add(matrix[curRow][curColumn]); visited[curRow][curColumn] = 1; int nextRow = curRow + directions[directionIndex][0], nextColumn = curColumn + directions[directionIndex][1]; if(nextRow &gt;= rows || nextRow &lt; 0 || nextColumn &gt;= columns || nextColumn &lt; 0 || visited[nextRow][nextColumn] == 1) directionIndex = (directionIndex + 1) % 4; curRow = curRow + directions[directionIndex][0]; curColumn = curColumn + directions[directionIndex][1]; &#125; return order;&#125; LC.11 乘最多水的容器 简介：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水链接：https://leetcode-cn.com/problems/container-with-most-water 技巧：利用双指针，left&amp;right，滑动判断最大面积。 123456789101112131415public int maxArea(int[] height) &#123; int maxRes = 0; int leftIndex = 0, rightIndex = height.length - 1; while(leftIndex &lt; rightIndex)&#123; int curRes = (rightIndex - leftIndex) * Math.min(height[leftIndex],height[rightIndex]); maxRes = Math.max(maxRes, curRes); if(height[leftIndex] &lt;= height[rightIndex])&#123; leftIndex++; &#125; else&#123; rightIndex--; &#125; &#125; return maxRes; &#125; JZ.04 二维数组中的查找 简介：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof思路：从右上角开始判断。 123456789101112131415161718public boolean findNumberIn2DArray(int[][] matrix,int target)&#123; if(matrix == null || matrix.length == 0 || matrix[0].length == 0)return false; boolean res = false; int j = matrix[0].length - 1, i = 0; while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; matrix.length &amp;&amp; j &lt;matrix[0].length)&#123; if(matrix[i][j] == target)&#123; res = true; break; &#125; else if(matrix[i][j] &lt; target)&#123; i++; &#125; else&#123; j--; &#125; &#125; return res;&#125; LC.73 矩阵置零 简介：给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**原地算法。** 思路：利用额外空间记录为0的行号和列号，再统一置零。 12345678910111213141516171819public void setZeros(int[][] matrix)&#123; boolean[] flagedRows = new boolean[matrix.length]; boolean[] flagedCols = new boolean[matrix[0].length]; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; if(matrix[i][j] == 0)&#123; flagedRows[i] = true; flagedCols[j] = true; &#125; &#125; &#125; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; if(flagedRows[i] || flagedCols[j])&#123; matrix[i][j] = 0; &#125; &#125; &#125;&#125; LC48. 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 思路：通过先水平翻转，再沿主对角线翻转的方式实现90度旋转。 1234567891011121314151617181920public void rotate(int[][] matrix) &#123; int rows = matrix.length; int cols = rows; //水平翻转 for (int i = 0; i &lt; rows/2; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[rows-1-i][j]; matrix[rows-1-i][j] = temp; &#125; &#125; //沿左对角线翻转 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125;&#125; 动态规划LC.115不同的子序列 简介：给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）链接：https://leetcode-cn.com/problems/distinct-subsequences 1234567891011121314151617181920212223242526272829public static int numDistinct(String s, String t)&#123; if (s.length() &lt; t.length()) return 0; int[][] dp = new int[t.length()+1][s.length()+1]; //dp初始化 for(int i = 0; i &lt;= t.length(); i++)&#123; for(int j = 0; j &lt;= s.length(); j++)&#123; dp[i][j] = 0; &#125; &#125; for(int j = 0; j &lt;= s.length(); j++)&#123; dp[0][j] = 1; &#125; //printMatrix(dp); for(int i = 1; i &lt;= t.length(); i++)&#123; for(int j = 1; j &lt;= s.length(); j++)&#123; if(s.charAt(j-1) == t.charAt(i-1))&#123; dp[i][j] = dp[i-1][j-1] + dp[i][j-1]; &#125; else&#123; dp[i][j] = dp[i][j - 1]; &#125; &#125; //printMatrix(dp); &#125; //printMatrix(dp); return dp[t.length()][s.length()]; &#125; LC.53 最大子序和 简介：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 思路：一维动态规划 12345678public int maxSubArray(int[] nums) &#123; int maxSum = nums[0]; for(int i=1; i&lt;nums.length; i++)&#123; nums[i] = Math.max(nums[i], nums[i - 1] + nums[i]); maxSum = Math.max(maxSum, nums[i]); &#125; return maxSum;&#125; LC.62不同路径 简介：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？链接：https://leetcode-cn.com/problems/unique-paths 思路：动态规划 12345678910111213141516public int uniquePaths(int m, int n) &#123; if(m == 1 || n == 1) return 1; int[][] dp = new int[m][n]; for(int i = 0; i&lt; m; i++)&#123; for(int j = 0; j&lt;n;j++)&#123; if(j==0 || i==0)dp[i][j]=1; else dp[i][j] = 0; &#125; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j&lt;n ;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125; LC.63不同路径 II 简介：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 思路：动态规划解决，遇到障碍物时要减去减少的可能路径。 12345678910111213141516171819202122232425public static int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[] rows = new int[m], cols = new int[n]; int[][] dp = new int[m][n]; for(int i = 0; i&lt; m;i ++)&#123; if(obstacleGrid[i][0] == 1) break; dp[i][0] = 1; &#125; for(int j = 0; j&lt;n;j++)&#123; if(obstacleGrid[0][j]==1)break; dp[0][j]=1; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j&lt;n ;j++)&#123; if(obstacleGrid[i][j] == 1)&#123; dp[i][j] = 0; &#125; else &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; &#125; //printMatrix(dp); return dp[m-1][n-1];&#125; LC.120 三角形最小路径和 简介：给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。链接：https://leetcode-cn.com/problems/triangle思路：运用动态规划，用二维数组记录状态，考虑好边界条件和推导式的特殊情况。 1234567891011121314151617181920public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int n = triangle.size(); int[][] dp = new int[n][n]; //初始化dp dp[0][0] = triangle.get(0).get(0); for(int i = 1; i &lt; n; i++)&#123; //每行的最左测 dp[i][0] = dp[i-1][0] + triangle.get(i).get(0); for(int j = 1; j &lt; i; j++)&#123; dp[i][j] = Math.min(dp[i-1][j-1],dp[i-1][j]) + triangle.get(i).get(j); &#125; //每行的最右侧 dp[i][i] = dp[i-1][i - 1] + triangle.get(i).get(i); &#125; int minTotal = dp[n-1][0]; for(int i = 1 ;i &lt; n ;i++)&#123; minTotal = Math.min(minTotal, dp[n-1][i]); &#125; return minTotal;&#125; 链表LC.92 反转链表Ⅱ 简介：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。链接：https://leetcode-cn.com/problems/reverse-linked-list-ii 思路：考虑到头节点可能变化的链表题，可以建立dummy node 来作为虚拟头节点。链表的反转可以通过三个点完成，curNode,nextNode,nextNextNode. 先将nextNode指向curNode，再使curNode=nextnode，nextnode=nextNextNode。 123456789101112131415161718public ListNode reverseBetween(ListNode head, int left, int right)&#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt; left - 1; i++)&#123; pre = pre.next; &#125; ListNode curNode = pre.next, nextNode = curNode.next; for(int i = 0 ; i &lt; right - left; i++)&#123; ListNode nextNextNode = nextNode.next; nextNode.next = curNode; curNode = nextNode; nextNode = nextNextNode; &#125; pre.next.next=nextNode; pre.next = curNode; return dummy.next;&#125; JZ.06从尾到头打印链表 简介：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 思路：1.用栈的特性解题，2 12345678910111213public int[] reversePrint(ListNode head) &#123; int count =0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(;head != null;head = head.next)&#123; stack.add(head.val); count++; &#125; int[] res = new int[count]; for(int i = 0; i &lt; count; i++)&#123; res[i] = stack.pop(); &#125; return res;&#125; LC82删除排序链表中的重复元素 II 简介：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。返回同样按升序排列的结果链表。 思路：针对头节点可能删除的情况，采用dummy node，注意考虑链表节点是否为null（null.next会报错） 12345678910111213141516171819202122public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode preNode = dummy; ListNode currentNode = head; while(currentNode != null &amp;&amp; currentNode.next!= null)&#123; if(currentNode.next.val == currentNode.val)&#123; ListNode postNode = currentNode.next; while(postNode!= null &amp;&amp; postNode.val == currentNode.val)&#123; postNode = postNode.next; &#125; preNode.next = postNode; currentNode = postNode; &#125; else&#123; preNode = currentNode; currentNode = currentNode.next; &#125; &#125; return dummy.next;&#125; LC328奇偶列表 简介：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。链接：https://leetcode-cn.com/problems/odd-even-linked-list 思路：要考虑边界值，通过维护两个指针达到奇偶分离的效果。 123456789101112131415public ListNode oddEvenList(ListNode head) &#123; //判断特殊情况 if(head == null) return head; ListNode evenHead = head.next; ListNode oddNode = head, evenNode = evenHead; while(evenNode != null &amp;&amp; evenNode.next != null)&#123; oddNode.next = evenNode.next; evenNode.next = evenNode.next.next; oddNode = oddNode.next; evenNode = evenNode.next; &#125; oddNode.next = evenHead; return head;&#125; LC19 简介： 思路：dummy 节点 ，双指针记录倒数第n个节点 1234567891011121314//因为头节点可能被删除，所以建立dummy节点ListNode dummy = new ListNode(0, head);//建立双指针，记录倒数第n个数ListNode first = head;ListNode second = dummy;for (int i = 0; i &lt; n; ++i) &#123; first = first.next;&#125;while (first != null) &#123; first = first.next; second = second.next;&#125;second.next = second.next.next;return dummy.next; LC83.删除排序链表中的重复元素 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 思路：遍历链表即可，如有重复，将该节点从链表中移除，注意判断结束条件。 123456789101112public ListNode deleteDuplicates(ListNode head) &#123; ListNode curNode = head; while(curNode != null &amp;&amp; curNode.next != null)&#123; if(curNode.val == curNode.next.val)&#123; curNode.next = curNode.next.next; &#125; else&#123; curNode = curNode.next; &#125; &#125; return head;&#125; 栈LC150 简介：根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation思路：运用栈的思想进行运算，遇到数字放入，遇到符号计算，记住String到Int类型的转换，可以编写辅助函数简化程序。 123456789101112131415161718192021222324public static int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; for (String token: tokens) &#123; if(isNumber(token))&#123; stack.push(Integer.parseInt(token)); &#125; else&#123; int num2 = stack.pop(),num1 = stack.pop(); switch (token)&#123; case &quot;+&quot; : stack.push(num1+num2);break; case &quot;-&quot; : stack.push(num1-num2);break; case &quot;*&quot; : stack.push(num1*num2);break; case &quot;/&quot; : stack.push(num1/num2);break; default: &#125; &#125; &#125; return stack.pop();&#125;public static boolean isNumber(String s)&#123; if(s.equals(&quot;+&quot;) &amp;&amp;s.equals(&quot;-&quot;) &amp;&amp;s.equals(&quot;*&quot;) &amp;&amp;s.equals(&quot;/&quot;))return true; else return false;&#125; LC456.132模式 简介：给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false链接：https://leetcode-cn.com/problems/132-pattern思路： 1234567891011121314151617public boolean find132pattern(int[] nums) &#123; Deque&lt;Integer&gt; possibleK = new LinkedList&lt;Integer&gt;(); possibleK.push(nums[nums.length - 1]); int maxK = Integer.MIN_VALUE; for(int i = nums.length - 2; i&gt;=0; i--)&#123; if(nums[i] &lt; maxK)&#123; return true; &#125; while(!possibleK.isEmpty() &amp;&amp; nums[i] &gt; possibleK.peek())&#123; maxK = possibleK.pop(); &#125; if(nums[i] &gt; maxK)&#123; possibleK.push(nums[i]); &#125; &#125; return false;&#125; 位运算LC.191 位1的个数 简介：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 思路：n&amp;（1&lt;&lt;i） 或者 n&amp;（n-1） 123456789public int hammingWeight(int n) &#123; int res = 0; for(int i=0; i&lt;32; i++)&#123; if((n&amp;(1&lt;&lt;i)) != 0)&#123; res++; &#125; &#125; return res;&#125; 排序LC.56 合并区间 简介：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 思路：先针对左端点排序（调用sort方法并自定义比较器），再通过对比右端点合并区间， 1234567891011121314151617181920public int[][] merge(int[][] intervals) &#123; //按区间的左端点排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return o1[0] - o2[0]; &#125; &#125;); List&lt;int[]&gt; merged = new ArrayList&lt;int[]&gt;(); for (int i = 0; i &lt; intervals.length; i++) &#123; int left = intervals[i][0],right = intervals[i][1]; if(merged.size() == 0 || merged.get(merged.size()-1)[1] &lt; left )&#123; merged.add(new int[]&#123;left,right&#125;); &#125; else&#123; merged.get(merged.size()-1)[1] = Math.max(right, merged.get(merged.size()-1)[1]); &#125; &#125; return merged.toArray(new int[merged.size()][]);&#125; LC148 排序链表 简介： 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 ， 思路：使用归并排序，且不使用递归的方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public ListNode sortList(ListNode head) &#123; if(head == null)&#123;return head;&#125; int length = 0; ListNode node = head; while(node != null)&#123; length++; node = node.next; &#125; ListNode dummy = new ListNode(-1 ,head); //最外层循环，控制子链表的长度 for (int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123; //两两一组，遍历目前长度下的所有子链表 ListNode curNode = dummy.next, preNode = dummy; while(curNode != null)&#123; //第一个子链表 ListNode head1 = curNode; for (int i = 1; i &lt; subLength &amp;&amp; curNode.next!= null; i++) &#123; curNode =curNode.next; &#125; //第二个子链表 ListNode head2 = curNode.next; curNode.next = null; curNode = head2; for (int i = 1; i &lt; subLength &amp;&amp; curNode != null; i++) &#123; curNode = curNode.next; &#125; //记录下剩余的链表的起始位置 ListNode next = null; if(curNode != null)&#123; next = curNode.next; curNode.next = null; &#125; //合并子链表 ListNode merged = merge(head1,head2); //将子链表重新插入原链表中 preNode.next = merged; //重新定位preNode和curNode while(preNode.next != null)&#123;preNode= preNode.next;&#125; curNode=next; &#125; &#125; return dummy.next;&#125;private ListNode merge(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode curNode = dummy; while (l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; curNode.next = l1; l1 = l1.next; &#125; else&#123; curNode.next = l2; l2 = l2.next; &#125; curNode = curNode.next; &#125; if(l1 != null) curNode.next = l1; if(l2 != null) curNode.next = l2; return dummy.next;&#125; 贪心算法55. 跳跃游戏 待做题LC969煎饼排序","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"初探反射","slug":"初探反射","date":"2021-04-02T03:18:04.000Z","updated":"2021-04-02T11:07:50.000Z","comments":true,"path":"2021/04/02/初探反射/","link":"","permalink":"http://example.com/2021/04/02/%E5%88%9D%E6%8E%A2%E5%8F%8D%E5%B0%84/","excerpt":"","text":"什么是反射？​ 反射是JAVA的特性之一，其运行JAVA程序在运行时获取类的信息，并且可以操作类或对象的内部属性。 ​ JAVA的反射机制使得程序可以在运行时动态的创建对象并调用其属性，不需要在编译期间确定对象的类型。当通过反射与一个未知类型的对象打交道时，JVM只是简单的检查这个对象，看它属于哪一个类，在用它做其他事情之前必须先加载那个类的Class对象。对于RTTI而言，编译器在编译是打开和检查.class文件。而对于反射机制来说，.class文件是在运行时被打开和检查的。 ​ JAVA的反射主要有以下几个功能： ​ 在运行时判断任意一个对象所属的类； ​ 在运行时构造任意一个类的对象； ​ 在运行时判断任意一个类所具有的成员变量； ​ 在运行时调用任意一个对象的方法； 反射的用途​ 反射最重要的用途就是开发各种通用框架。如Spring就是配置化的，需要根据配置文件加载不同的对象或类，调用不同的方法，这时候就需要用到反射，在运行时动态加载对象。 反射的基本运用​ Class类与java.lang.reflect类库一起对反射的概念进行了支持，reflect类库包含了Field、Method和Constructor类。这些类型的对象会由JVM在运行时创建，用于未知类中的成员。所以可以运用Constructor来创建新的对象，用get()和set()方法读取和修改Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。此外，还可以调用getFields()、getMethods()和getConstructors()等方法获得更多类的信息。以下是反射一些基本运用的示例：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Hexo 个人博客搭建教程","slug":"Hexo-个人博客搭建教程","date":"2021-04-01T05:41:06.000Z","updated":"2021-04-01T05:41:06.518Z","comments":true,"path":"2021/04/01/Hexo-个人博客搭建教程/","link":"","permalink":"http://example.com/2021/04/01/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-03-31T18:04:30.893Z","updated":"2021-03-31T18:04:30.893Z","comments":true,"path":"2021/04/01/hello-world/","link":"","permalink":"http://example.com/2021/04/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"}]}